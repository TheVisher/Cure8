/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sentry+opentelemetry@10.16_6ab421456e2f0bf04c66c14f54985fe1";
exports.ids = ["vendor-chunks/@sentry+opentelemetry@10.16_6ab421456e2f0bf04c66c14f54985fe1"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@sentry+opentelemetry@10.16_6ab421456e2f0bf04c66c14f54985fe1/node_modules/@sentry/opentelemetry/build/cjs/index.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sentry+opentelemetry@10.16_6ab421456e2f0bf04c66c14f54985fe1/node_modules/@sentry/opentelemetry/build/cjs/index.js ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst semanticConventions = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.37.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst core = __webpack_require__(/*! @sentry/core */ \"(rsc)/./node_modules/.pnpm/@sentry+core@10.16.0/node_modules/@sentry/core/build/cjs/index.js\");\nconst api = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core$1 = __webpack_require__(/*! @opentelemetry/core */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+core@2.1.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst sdkTraceBase = __webpack_require__(/*! @opentelemetry/sdk-trace-base */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.1.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\");\n\n/** If this attribute is true, it means that the parent is a remote span. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE = 'sentry.parentIsRemote';\n\n// These are not standardized yet, but used by the graphql instrumentation\nconst SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = 'sentry.graphql.operation';\n\n/**\n * Get the parent span id from a span.\n * In OTel v1, the parent span id is accessed as `parentSpanId`\n * In OTel v2, the parent span id is accessed as `spanId` on the `parentSpanContext`\n */\nfunction getParentSpanId(span) {\n  if ('parentSpanId' in span) {\n    return span.parentSpanId ;\n  } else if ('parentSpanContext' in span) {\n    return (span.parentSpanContext )?.spanId;\n  }\n\n  return undefined;\n}\n\n/**\n * Check if a given span has attributes.\n * This is necessary because the base `Span` type does not have attributes,\n * so in places where we are passed a generic span, we need to check if we want to access them.\n */\nfunction spanHasAttributes(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.attributes && typeof castSpan.attributes === 'object';\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasKind(span) {\n  const castSpan = span ;\n  return typeof castSpan.kind === 'number';\n}\n\n/**\n * Check if a given span has a status.\n * This is necessary because the base `Span` type does not have a status,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasStatus(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.status;\n}\n\n/**\n * Check if a given span has a name.\n * This is necessary because the base `Span` type does not have a name,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasName(span) {\n  const castSpan = span ;\n  return !!castSpan.name;\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasParentId(\n  span,\n) {\n  const castSpan = span ;\n  return !!getParentSpanId(castSpan);\n}\n\n/**\n * Check if a given span has events.\n * This is necessary because the base `Span` type does not have events,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasEvents(\n  span,\n) {\n  const castSpan = span ;\n  return Array.isArray(castSpan.events);\n}\n\n/**\n * Get sanitizied request data from an OTEL span.\n */\nfunction getRequestSpanData(span) {\n  // The base `Span` type has no `attributes`, so we need to guard here against that\n  if (!spanHasAttributes(span)) {\n    return {};\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const maybeUrlAttribute = (span.attributes[semanticConventions.ATTR_URL_FULL] || span.attributes[semanticConventions.SEMATTRS_HTTP_URL])\n\n;\n\n  const data = {\n    url: maybeUrlAttribute,\n    // eslint-disable-next-line deprecation/deprecation\n    'http.method': (span.attributes[semanticConventions.ATTR_HTTP_REQUEST_METHOD] || span.attributes[semanticConventions.SEMATTRS_HTTP_METHOD])\n\n,\n  };\n\n  // Default to GET if URL is set but method is not\n  if (!data['http.method'] && data.url) {\n    data['http.method'] = 'GET';\n  }\n\n  try {\n    if (typeof maybeUrlAttribute === 'string') {\n      const url = core.parseUrl(maybeUrlAttribute);\n\n      data.url = core.getSanitizedUrlString(url);\n\n      if (url.search) {\n        data['http.query'] = url.search;\n      }\n      if (url.hash) {\n        data['http.fragment'] = url.hash;\n      }\n    }\n  } catch {\n    // ignore\n  }\n\n  return data;\n}\n\n// Typescript complains if we do not use `...args: any[]` for the mixin, with:\n// A mixin class must have a constructor with a single rest parameter of type 'any[]'.ts(2545)\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Wrap an Client class with things we need for OpenTelemetry support.\n * Make sure that the Client class passed in is non-abstract!\n *\n * Usage:\n * const OpenTelemetryClient = getWrappedClientClass(NodeClient);\n * const client = new OpenTelemetryClient(options);\n */\nfunction wrapClientClass\n\n(ClientClass) {\n  // @ts-expect-error We just assume that this is non-abstract, if you pass in an abstract class this would make it non-abstract\n  class OpenTelemetryClient extends ClientClass  {\n\n     constructor(...args) {\n      super(...args);\n    }\n\n    /** Get the OTEL tracer. */\n     get tracer() {\n      if (this._tracer) {\n        return this._tracer;\n      }\n\n      const name = '@sentry/opentelemetry';\n      const version = core.SDK_VERSION;\n      const tracer = api.trace.getTracer(name, version);\n      this._tracer = tracer;\n\n      return tracer;\n    }\n\n    /**\n     * @inheritDoc\n     */\n     async flush(timeout) {\n      const provider = this.traceProvider;\n      await provider?.forceFlush();\n      return super.flush(timeout);\n    }\n  }\n\n  return OpenTelemetryClient ;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * Get the span kind from a span.\n * For whatever reason, this is not public API on the generic \"Span\" type,\n * so we need to check if we actually have a `SDKTraceBaseSpan` where we can fetch this from.\n * Otherwise, we fall back to `SpanKind.INTERNAL`.\n */\nfunction getSpanKind(span) {\n  if (spanHasKind(span)) {\n    return span.kind;\n  }\n\n  return api.SpanKind.INTERNAL;\n}\n\nconst SENTRY_TRACE_HEADER = 'sentry-trace';\nconst SENTRY_BAGGAGE_HEADER = 'baggage';\n\nconst SENTRY_TRACE_STATE_DSC = 'sentry.dsc';\nconst SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING = 'sentry.sampled_not_recording';\nconst SENTRY_TRACE_STATE_URL = 'sentry.url';\nconst SENTRY_TRACE_STATE_SAMPLE_RAND = 'sentry.sample_rand';\nconst SENTRY_TRACE_STATE_SAMPLE_RATE = 'sentry.sample_rate';\n\nconst SENTRY_SCOPES_CONTEXT_KEY = api.createContextKey('sentry_scopes');\n\nconst SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_isolation_scope');\n\nconst SENTRY_FORK_SET_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_set_scope');\n\nconst SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_set_isolation_scope');\n\nconst SCOPE_CONTEXT_FIELD = '_scopeContext';\n\n/**\n * Try to get the current scopes from the given OTEL context.\n * This requires a Context Manager that was wrapped with getWrappedContextManager.\n */\nfunction getScopesFromContext(context) {\n  return context.getValue(SENTRY_SCOPES_CONTEXT_KEY) ;\n}\n\n/**\n * Set the current scopes on an OTEL context.\n * This will return a forked context with the Propagation Context set.\n */\nfunction setScopesOnContext(context, scopes) {\n  return context.setValue(SENTRY_SCOPES_CONTEXT_KEY, scopes);\n}\n\n/**\n * Set the context on the scope so we can later look it up.\n * We need this to get the context from the scope in the `trace` functions.\n */\nfunction setContextOnScope(scope, context) {\n  core.addNonEnumerableProperty(scope, SCOPE_CONTEXT_FIELD, context);\n}\n\n/**\n * Get the context related to a scope.\n */\nfunction getContextFromScope(scope) {\n  return (scope )[SCOPE_CONTEXT_FIELD];\n}\n\n/**\n *\n * @param otelSpan Checks whether a given OTEL Span is an http request to sentry.\n * @returns boolean\n */\nfunction isSentryRequestSpan(span) {\n  if (!spanHasAttributes(span)) {\n    return false;\n  }\n\n  const { attributes } = span;\n\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `ATTR_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL] || attributes[semanticConventions.ATTR_URL_FULL];\n\n  if (!httpUrl) {\n    return false;\n  }\n\n  return core.isSentryRequestUrl(httpUrl.toString(), core.getClient());\n}\n\n/**\n * OpenTelemetry only knows about SAMPLED or NONE decision,\n * but for us it is important to differentiate between unset and unsampled.\n *\n * Both of these are identified as `traceFlags === TracegFlags.NONE`,\n * but we additionally look at a special trace state to differentiate between them.\n */\nfunction getSamplingDecision(spanContext) {\n  const { traceFlags, traceState } = spanContext;\n\n  const sampledNotRecording = traceState ? traceState.get(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING) === '1' : false;\n\n  // If trace flag is `SAMPLED`, we interpret this as sampled\n  // If it is `NONE`, it could mean either it was sampled to be not recorder, or that it was not sampled at all\n  // For us this is an important difference, sow e look at the SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING\n  // to identify which it is\n  if (traceFlags === api.TraceFlags.SAMPLED) {\n    return true;\n  }\n\n  if (sampledNotRecording) {\n    return false;\n  }\n\n  // Fall back to DSC as a last resort, that may also contain `sampled`...\n  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n  const dsc = dscString ? core.baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n  if (dsc?.sampled === 'true') {\n    return true;\n  }\n  if (dsc?.sampled === 'false') {\n    return false;\n  }\n\n  return undefined;\n}\n\n/**\n * Infer the op & description for a set of name, attributes and kind of a span.\n */\nfunction inferSpanData(spanName, attributes, kind) {\n  // if http.method exists, this is an http request span\n  // eslint-disable-next-line deprecation/deprecation\n  const httpMethod = attributes[semanticConventions.ATTR_HTTP_REQUEST_METHOD] || attributes[semanticConventions.SEMATTRS_HTTP_METHOD];\n  if (httpMethod) {\n    return descriptionForHttpMethod({ attributes, name: spanName, kind }, httpMethod);\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const dbSystem = attributes[semanticConventions.SEMATTRS_DB_SYSTEM];\n  const opIsCache =\n    typeof attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] === 'string' &&\n    attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP].startsWith('cache.');\n\n  // If db.type exists then this is a database call span\n  // If the Redis DB is used as a cache, the span description should not be changed\n  if (dbSystem && !opIsCache) {\n    return descriptionForDbSystem({ attributes, name: spanName });\n  }\n\n  const customSourceOrRoute = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom' ? 'custom' : 'route';\n\n  // If rpc.service exists then this is a rpc call span.\n  // eslint-disable-next-line deprecation/deprecation\n  const rpcService = attributes[semanticConventions.SEMATTRS_RPC_SERVICE];\n  if (rpcService) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, 'route'),\n      op: 'rpc',\n    };\n  }\n\n  // If messaging.system exists then this is a messaging system span.\n  // eslint-disable-next-line deprecation/deprecation\n  const messagingSystem = attributes[semanticConventions.SEMATTRS_MESSAGING_SYSTEM];\n  if (messagingSystem) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),\n      op: 'message',\n    };\n  }\n\n  // If faas.trigger exists then this is a function as a service span.\n  // eslint-disable-next-line deprecation/deprecation\n  const faasTrigger = attributes[semanticConventions.SEMATTRS_FAAS_TRIGGER];\n  if (faasTrigger) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),\n      op: faasTrigger.toString(),\n    };\n  }\n\n  return { op: undefined, description: spanName, source: 'custom' };\n}\n\n/**\n * Extract better op/description from an otel span.\n *\n * Does not overwrite the span name if the source is already set to custom to ensure\n * that user-updated span names are preserved. In this case, we only adjust the op but\n * leave span description and source unchanged.\n *\n * Based on https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/7422ce2a06337f68a59b552b8c5a2ac125d6bae5/exporter/sentryexporter/sentry_exporter.go#L306\n */\nfunction parseSpanDescription(span) {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const name = spanHasName(span) ? span.name : '<unknown>';\n  const kind = getSpanKind(span);\n\n  return inferSpanData(name, attributes, kind);\n}\n\nfunction descriptionForDbSystem({ attributes, name }) {\n  // if we already have a custom name, we don't overwrite it but only set the op\n  const userDefinedName = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n  if (typeof userDefinedName === 'string') {\n    return {\n      op: 'db',\n      description: userDefinedName,\n      source: (attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ) || 'custom',\n    };\n  }\n\n  // if we already have the source set to custom, we don't overwrite the span description but only set the op\n  if (attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom') {\n    return { op: 'db', description: name, source: 'custom' };\n  }\n\n  // Use DB statement (Ex \"SELECT * FROM table\") if possible as description.\n  // eslint-disable-next-line deprecation/deprecation\n  const statement = attributes[semanticConventions.SEMATTRS_DB_STATEMENT];\n\n  const description = statement ? statement.toString() : name;\n\n  return { op: 'db', description, source: 'task' };\n}\n\n/** Only exported for tests. */\nfunction descriptionForHttpMethod(\n  { name, kind, attributes },\n  httpMethod,\n) {\n  const opParts = ['http'];\n\n  switch (kind) {\n    case api.SpanKind.CLIENT:\n      opParts.push('client');\n      break;\n    case api.SpanKind.SERVER:\n      opParts.push('server');\n      break;\n  }\n\n  // Spans for HTTP requests we have determined to be prefetch requests will have a `.prefetch` postfix in the op\n  if (attributes['sentry.http.prefetch']) {\n    opParts.push('prefetch');\n  }\n\n  const { urlPath, url, query, fragment, hasRoute } = getSanitizedUrl(attributes, kind);\n\n  if (!urlPath) {\n    return { ...getUserUpdatedNameAndSource(name, attributes), op: opParts.join('.') };\n  }\n\n  const graphqlOperationsAttribute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION];\n\n  // Ex. GET /api/users\n  const baseDescription = `${httpMethod} ${urlPath}`;\n\n  // When the http span has a graphql operation, append it to the description\n  // We add these in the graphqlIntegration\n  const inferredDescription = graphqlOperationsAttribute\n    ? `${baseDescription} (${getGraphqlOperationNamesFromAttribute(graphqlOperationsAttribute)})`\n    : baseDescription;\n\n  // If `httpPath` is a root path, then we can categorize the transaction source as route.\n  const inferredSource = hasRoute || urlPath === '/' ? 'route' : 'url';\n\n  const data = {};\n\n  if (url) {\n    data.url = url;\n  }\n  if (query) {\n    data['http.query'] = query;\n  }\n  if (fragment) {\n    data['http.fragment'] = fragment;\n  }\n\n  // If the span kind is neither client nor server, we use the original name\n  // this infers that somebody manually started this span, in which case we don't want to overwrite the name\n  const isClientOrServerKind = kind === api.SpanKind.CLIENT || kind === api.SpanKind.SERVER;\n\n  // If the span is an auto-span (=it comes from one of our instrumentations),\n  // we always want to infer the name\n  // this is necessary because some of the auto-instrumentation we use uses kind=INTERNAL\n  const origin = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] || 'manual';\n  const isManualSpan = !`${origin}`.startsWith('auto');\n\n  // If users (or in very rare occasions we) set the source to custom, we don't overwrite the name\n  const alreadyHasCustomSource = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom';\n  const customSpanName = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n\n  const useInferredDescription =\n    !alreadyHasCustomSource && customSpanName == null && (isClientOrServerKind || !isManualSpan);\n\n  const { description, source } = useInferredDescription\n    ? { description: inferredDescription, source: inferredSource }\n    : getUserUpdatedNameAndSource(name, attributes);\n\n  return {\n    op: opParts.join('.'),\n    description,\n    source,\n    data,\n  };\n}\n\nfunction getGraphqlOperationNamesFromAttribute(attr) {\n  if (Array.isArray(attr)) {\n    const sorted = attr.slice().sort();\n\n    // Up to 5 items, we just add all of them\n    if (sorted.length <= 5) {\n      return sorted.join(', ');\n    } else {\n      // Else, we add the first 5 and the diff of other operations\n      return `${sorted.slice(0, 5).join(', ')}, +${sorted.length - 5}`;\n    }\n  }\n\n  return `${attr}`;\n}\n\n/** Exported for tests only */\nfunction getSanitizedUrl(\n  attributes,\n  kind,\n)\n\n {\n  // This is the relative path of the URL, e.g. /sub\n  // eslint-disable-next-line deprecation/deprecation\n  const httpTarget = attributes[semanticConventions.SEMATTRS_HTTP_TARGET];\n  // This is the full URL, including host & query params etc., e.g. https://example.com/sub?foo=bar\n  // eslint-disable-next-line deprecation/deprecation\n  const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL] || attributes[semanticConventions.ATTR_URL_FULL];\n  // This is the normalized route name - may not always be available!\n  const httpRoute = attributes[semanticConventions.ATTR_HTTP_ROUTE];\n\n  const parsedUrl = typeof httpUrl === 'string' ? core.parseUrl(httpUrl) : undefined;\n  const url = parsedUrl ? core.getSanitizedUrlString(parsedUrl) : undefined;\n  const query = parsedUrl?.search || undefined;\n  const fragment = parsedUrl?.hash || undefined;\n\n  if (typeof httpRoute === 'string') {\n    return { urlPath: httpRoute, url, query, fragment, hasRoute: true };\n  }\n\n  if (kind === api.SpanKind.SERVER && typeof httpTarget === 'string') {\n    return { urlPath: core.stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  if (parsedUrl) {\n    return { urlPath: url, url, query, fragment, hasRoute: false };\n  }\n\n  // fall back to target even for client spans, if no URL is present\n  if (typeof httpTarget === 'string') {\n    return { urlPath: core.stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  return { urlPath: undefined, url, query, fragment, hasRoute: false };\n}\n\n/**\n * Because Otel instrumentation sometimes mutates span names via `span.updateName`, the only way\n * to ensure that a user-set span name is preserved is to store it as a tmp attribute on the span.\n * We delete this attribute once we're done with it when preparing the event envelope.\n *\n * This temp attribute always takes precedence over the original name.\n *\n * We also need to take care of setting the correct source. Users can always update the source\n * after updating the name, so we need to respect that.\n *\n * @internal exported only for testing\n */\nfunction getUserUpdatedNameAndSource(\n  originalName,\n  attributes,\n  fallbackSource = 'custom',\n)\n\n {\n  const source = (attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ) || fallbackSource;\n  const description = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n\n  if (description && typeof description === 'string') {\n    return {\n      description,\n      source,\n    };\n  }\n\n  return { description: originalName, source };\n}\n\n/**\n * Setup a DSC handler on the passed client,\n * ensuring that the transaction name is inferred from the span correctly.\n */\nfunction enhanceDscWithOpenTelemetryRootSpanName(client) {\n  client.on('createDsc', (dsc, rootSpan) => {\n    if (!rootSpan) {\n      return;\n    }\n\n    // We want to overwrite the transaction on the DSC that is created by default in core\n    // The reason for this is that we want to infer the span name, not use the initial one\n    // Otherwise, we'll get names like \"GET\" instead of e.g. \"GET /foo\"\n    // `parseSpanDescription` takes the attributes of the span into account for the name\n    // This mutates the passed-in DSC\n\n    const jsonSpan = core.spanToJSON(rootSpan);\n    const attributes = jsonSpan.data;\n    const source = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n    const { description } = spanHasName(rootSpan) ? parseSpanDescription(rootSpan) : { description: undefined };\n    if (source !== 'url' && description) {\n      dsc.transaction = description;\n    }\n\n    // Also ensure sampling decision is correctly inferred\n    // In core, we use `spanIsSampled`, which just looks at the trace flags\n    // but in OTEL, we use a slightly more complex logic to be able to differntiate between unsampled and deferred sampling\n    if (core.hasSpansEnabled()) {\n      const sampled = getSamplingDecision(rootSpan.spanContext());\n      dsc.sampled = sampled == undefined ? undefined : String(sampled);\n    }\n  });\n}\n\n/**\n * Returns the currently active span.\n */\nfunction getActiveSpan() {\n  return api.trace.getActiveSpan();\n}\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\n/**\n * Generate a TraceState for the given data.\n */\nfunction makeTraceState({\n  dsc,\n  sampled,\n}\n\n) {\n  // We store the DSC as OTEL trace state on the span context\n  const dscString = dsc ? core.dynamicSamplingContextToSentryBaggageHeader(dsc) : undefined;\n\n  const traceStateBase = new core$1.TraceState();\n\n  const traceStateWithDsc = dscString ? traceStateBase.set(SENTRY_TRACE_STATE_DSC, dscString) : traceStateBase;\n\n  // We also specifically want to store if this is sampled to be not recording,\n  // or unsampled (=could be either sampled or not)\n  return sampled === false ? traceStateWithDsc.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') : traceStateWithDsc;\n}\n\nconst setupElements = new Set();\n\n/** Get all the OpenTelemetry elements that have been set up. */\nfunction openTelemetrySetupCheck() {\n  return Array.from(setupElements);\n}\n\n/** Mark an OpenTelemetry element as setup. */\nfunction setIsSetup(element) {\n  setupElements.add(element);\n}\n\n/**\n * Injects and extracts `sentry-trace` and `baggage` headers from carriers.\n */\nclass SentryPropagator extends core$1.W3CBaggagePropagator {\n  /** A map of URLs that have already been checked for if they match tracePropagationTargets. */\n\n   constructor() {\n    super();\n    setIsSetup('SentryPropagator');\n\n    // We're caching results so we don't have to recompute regexp every time we create a request.\n    this._urlMatchesTargetsMap = new core.LRUMap(100);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   inject(context, carrier, setter) {\n    if (core$1.isTracingSuppressed(context)) {\n      DEBUG_BUILD && core.debug.log('[Tracing] Not injecting trace data for url because tracing is suppressed.');\n      return;\n    }\n\n    const activeSpan = api.trace.getSpan(context);\n    const url = activeSpan && getCurrentURL(activeSpan);\n\n    const tracePropagationTargets = core.getClient()?.getOptions()?.tracePropagationTargets;\n    if (!shouldPropagateTraceForUrl(url, tracePropagationTargets, this._urlMatchesTargetsMap)) {\n      DEBUG_BUILD &&\n        core.debug.log('[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:', url);\n      return;\n    }\n\n    const existingBaggageHeader = getExistingBaggage(carrier);\n    let baggage = api.propagation.getBaggage(context) || api.propagation.createBaggage({});\n\n    const { dynamicSamplingContext, traceId, spanId, sampled } = getInjectionData(context);\n\n    if (existingBaggageHeader) {\n      const baggageEntries = core.parseBaggageHeader(existingBaggageHeader);\n\n      if (baggageEntries) {\n        Object.entries(baggageEntries).forEach(([key, value]) => {\n          baggage = baggage.setEntry(key, { value });\n        });\n      }\n    }\n\n    if (dynamicSamplingContext) {\n      baggage = Object.entries(dynamicSamplingContext).reduce((b, [dscKey, dscValue]) => {\n        if (dscValue) {\n          return b.setEntry(`${core.SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`, { value: dscValue });\n        }\n        return b;\n      }, baggage);\n    }\n\n    // We also want to avoid setting the default OTEL trace ID, if we get that for whatever reason\n    if (traceId && traceId !== api.INVALID_TRACEID) {\n      setter.set(carrier, SENTRY_TRACE_HEADER, core.generateSentryTraceHeader(traceId, spanId, sampled));\n    }\n\n    super.inject(api.propagation.setBaggage(context, baggage), carrier, setter);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   extract(context, carrier, getter) {\n    const maybeSentryTraceHeader = getter.get(carrier, SENTRY_TRACE_HEADER);\n    const baggage = getter.get(carrier, SENTRY_BAGGAGE_HEADER);\n\n    const sentryTrace = maybeSentryTraceHeader\n      ? Array.isArray(maybeSentryTraceHeader)\n        ? maybeSentryTraceHeader[0]\n        : maybeSentryTraceHeader\n      : undefined;\n\n    // Add remote parent span context\n    // If there is no incoming trace, this will return the context as-is\n    return ensureScopesOnContext(getContextWithRemoteActiveSpan(context, { sentryTrace, baggage }));\n  }\n\n  /**\n   * @inheritDoc\n   */\n   fields() {\n    return [SENTRY_TRACE_HEADER, SENTRY_BAGGAGE_HEADER];\n  }\n}\n\nconst NOT_PROPAGATED_MESSAGE =\n  '[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:';\n\n/**\n * Check if a given URL should be propagated to or not.\n * If no url is defined, or no trace propagation targets are defined, this will always return `true`.\n * You can also optionally provide a decision map, to cache decisions and avoid repeated regex lookups.\n */\nfunction shouldPropagateTraceForUrl(\n  url,\n  tracePropagationTargets,\n  decisionMap,\n) {\n  if (typeof url !== 'string' || !tracePropagationTargets) {\n    return true;\n  }\n\n  const cachedDecision = decisionMap?.get(url);\n  if (cachedDecision !== undefined) {\n    DEBUG_BUILD && !cachedDecision && core.debug.log(NOT_PROPAGATED_MESSAGE, url);\n    return cachedDecision;\n  }\n\n  const decision = core.stringMatchesSomePattern(url, tracePropagationTargets);\n  decisionMap?.set(url, decision);\n\n  DEBUG_BUILD && !decision && core.debug.log(NOT_PROPAGATED_MESSAGE, url);\n  return decision;\n}\n\n/**\n * Get propagation injection data for the given context.\n * The additional options can be passed to override the scope and client that is otherwise derived from the context.\n */\nfunction getInjectionData(\n  context,\n  options = {},\n)\n\n {\n  const span = api.trace.getSpan(context);\n\n  // If we have a remote span, the spanId should be considered as the parentSpanId, not spanId itself\n  // Instead, we use a virtual (generated) spanId for propagation\n  if (span?.spanContext().isRemote) {\n    const spanContext = span.spanContext();\n    const dynamicSamplingContext = core.getDynamicSamplingContextFromSpan(span);\n\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: undefined,\n      sampled: getSamplingDecision(spanContext), // TODO: Do we need to change something here?\n    };\n  }\n\n  // If we have a local span, we just use this\n  if (span) {\n    const spanContext = span.spanContext();\n    const dynamicSamplingContext = core.getDynamicSamplingContextFromSpan(span);\n\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: spanContext.spanId,\n      sampled: getSamplingDecision(spanContext), // TODO: Do we need to change something here?\n    };\n  }\n\n  // Else we try to use the propagation context from the scope\n  // The only scenario where this should happen is when we neither have a span, nor an incoming trace\n  const scope = options.scope || getScopesFromContext(context)?.scope || core.getCurrentScope();\n  const client = options.client || core.getClient();\n\n  const propagationContext = scope.getPropagationContext();\n  const dynamicSamplingContext = client ? core.getDynamicSamplingContextFromScope(client, scope) : undefined;\n  return {\n    dynamicSamplingContext,\n    traceId: propagationContext.traceId,\n    spanId: propagationContext.propagationSpanId,\n    sampled: propagationContext.sampled,\n  };\n}\n\nfunction getContextWithRemoteActiveSpan(\n  ctx,\n  { sentryTrace, baggage },\n) {\n  const propagationContext = core.propagationContextFromHeaders(sentryTrace, baggage);\n\n  const { traceId, parentSpanId, sampled, dsc } = propagationContext;\n\n  const client = core.getClient();\n  const incomingDsc = core.baggageHeaderToDynamicSamplingContext(baggage);\n\n  // We only want to set the virtual span if we are continuing a concrete trace\n  // Otherwise, we ignore the incoming trace here, e.g. if we have no trace headers\n  if (!parentSpanId || (client && !core.shouldContinueTrace(client, incomingDsc?.org_id))) {\n    return ctx;\n  }\n\n  const spanContext = generateRemoteSpanContext({\n    traceId,\n    spanId: parentSpanId,\n    sampled,\n    dsc,\n  });\n\n  return api.trace.setSpanContext(ctx, spanContext);\n}\n\n/**\n * Takes trace strings and propagates them as a remote active span.\n * This should be used in addition to `continueTrace` in OTEL-powered environments.\n */\nfunction continueTraceAsRemoteSpan(\n  ctx,\n  options,\n  callback,\n) {\n  const ctxWithSpanContext = ensureScopesOnContext(getContextWithRemoteActiveSpan(ctx, options));\n\n  return api.context.with(ctxWithSpanContext, callback);\n}\n\nfunction ensureScopesOnContext(ctx) {\n  // If there are no scopes yet on the context, ensure we have them\n  const scopes = getScopesFromContext(ctx);\n  const newScopes = {\n    // If we have no scope here, this is most likely either the root context or a context manually derived from it\n    // In this case, we want to fork the current scope, to ensure we do not pollute the root scope\n    scope: scopes ? scopes.scope : core.getCurrentScope().clone(),\n    isolationScope: scopes ? scopes.isolationScope : core.getIsolationScope(),\n  };\n\n  return setScopesOnContext(ctx, newScopes);\n}\n\n/** Try to get the existing baggage header so we can merge this in. */\nfunction getExistingBaggage(carrier) {\n  try {\n    const baggage = (carrier )[SENTRY_BAGGAGE_HEADER];\n    return Array.isArray(baggage) ? baggage.join(',') : baggage;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * It is pretty tricky to get access to the outgoing request URL of a request in the propagator.\n * As we only have access to the context of the span to be sent and the carrier (=headers),\n * but the span may be unsampled and thus have no attributes.\n *\n * So we use the following logic:\n * 1. If we have an active span, we check if it has a URL attribute.\n * 2. Else, if the active span has no URL attribute (e.g. it is unsampled), we check a special trace state (which we set in our sampler).\n */\nfunction getCurrentURL(span) {\n  const spanData = core.spanToJSON(span).data;\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `SEMATTRS_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const urlAttribute = spanData[semanticConventions.SEMATTRS_HTTP_URL] || spanData[semanticConventions.ATTR_URL_FULL];\n  if (typeof urlAttribute === 'string') {\n    return urlAttribute;\n  }\n\n  // Also look at the traceState, which we may set in the sampler even for unsampled spans\n  const urlTraceState = span.spanContext().traceState?.get(SENTRY_TRACE_STATE_URL);\n  if (urlTraceState) {\n    return urlTraceState;\n  }\n\n  return undefined;\n}\n\nfunction generateRemoteSpanContext({\n  spanId,\n  traceId,\n  sampled,\n  dsc,\n}\n\n) {\n  // We store the DSC as OTEL trace state on the span context\n  const traceState = makeTraceState({\n    dsc,\n    sampled,\n  });\n\n  const spanContext = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n    traceState,\n  };\n\n  return spanContext;\n}\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpan(options, callback) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      return core.handleCallbackErrors(\n        () => callback(span),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (core.spanToJSON(span).status === undefined) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n          }\n        },\n        () => span.end(),\n      );\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a span, but does not finish the span\n * after the function is done automatically. You'll have to call `span.end()` manually.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpanManual(\n  options,\n  callback,\n) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      return core.handleCallbackErrors(\n        () => callback(span, () => span.end()),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (core.spanToJSON(span).status === undefined) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startInactiveSpan(options) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    const span = tracer.startSpan(name, spanOptions, ctx);\n\n    return span;\n  });\n}\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will be root spans.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nfunction withActiveSpan(span, callback) {\n  const newContextWithActiveSpan = span ? api.trace.setSpan(api.context.active(), span) : api.trace.deleteSpan(api.context.active());\n  return api.context.with(newContextWithActiveSpan, () => callback(core.getCurrentScope()));\n}\n\nfunction getTracer() {\n  const client = core.getClient();\n  return client?.tracer || api.trace.getTracer('@sentry/opentelemetry', core.SDK_VERSION);\n}\n\nfunction getSpanOptions(options) {\n  const { startTime, attributes, kind, op, links } = options;\n\n  // OTEL expects timestamps in ms, not seconds\n  const fixedStartTime = typeof startTime === 'number' ? ensureTimestampInMilliseconds(startTime) : startTime;\n\n  return {\n    attributes: op\n      ? {\n          [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n          ...attributes,\n        }\n      : attributes,\n    kind,\n    links,\n    startTime: fixedStartTime,\n  };\n}\n\nfunction ensureTimestampInMilliseconds(timestamp) {\n  const isMs = timestamp < 9999999999;\n  return isMs ? timestamp * 1000 : timestamp;\n}\n\nfunction getContext(scope, forceTransaction) {\n  const ctx = getContextForScope(scope);\n  const parentSpan = api.trace.getSpan(ctx);\n\n  // In the case that we have no parent span, we start a new trace\n  // Note that if we continue a trace, we'll always have a remote parent span here anyhow\n  if (!parentSpan) {\n    return ctx;\n  }\n\n  // If we don't want to force a transaction, and we have a parent span, all good, we just return as-is!\n  if (!forceTransaction) {\n    return ctx;\n  }\n\n  // Else, if we do have a parent span but want to force a transaction, we have to simulate a \"root\" context\n\n  // Else, we need to do two things:\n  // 1. Unset the parent span from the context, so we'll create a new root span\n  // 2. Ensure the propagation context is correct, so we'll continue from the parent span\n  const ctxWithoutSpan = api.trace.deleteSpan(ctx);\n\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = getSamplingDecision(parentSpan.spanContext());\n\n  // In this case, when we are forcing a transaction, we want to treat this like continuing an incoming trace\n  // so we set the traceState according to the root span\n  const rootSpan = core.getRootSpan(parentSpan);\n  const dsc = core.getDynamicSamplingContextFromSpan(rootSpan);\n\n  const traceState = makeTraceState({\n    dsc,\n    sampled,\n  });\n\n  const spanOptions = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n    traceState,\n  };\n\n  const ctxWithSpanContext = api.trace.setSpanContext(ctxWithoutSpan, spanOptions);\n\n  return ctxWithSpanContext;\n}\n\nfunction getContextForScope(scope) {\n  if (scope) {\n    const ctx = getContextFromScope(scope);\n    if (ctx) {\n      return ctx;\n    }\n  }\n\n  return api.context.active();\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n * and `<meta name=\"baggage\">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n *\n * This is a custom version of `continueTrace` that is used in OTEL-powered environments.\n * It propagates the trace as a remote span, in addition to setting it on the propagation context.\n */\nfunction continueTrace(options, callback) {\n  return continueTraceAsRemoteSpan(api.context.active(), options, callback);\n}\n\n/**\n * Get the trace context for a given scope.\n * We have a custom implementation here because we need an OTEL-specific way to get the span from a scope.\n */\nfunction getTraceContextForScope(\n  client,\n  scope,\n) {\n  const ctx = getContextFromScope(scope);\n  const span = ctx && api.trace.getSpan(ctx);\n\n  const traceContext = span ? core.spanToTraceContext(span) : core.getTraceContextFromScope(scope);\n\n  const dynamicSamplingContext = span\n    ? core.getDynamicSamplingContextFromSpan(span)\n    : core.getDynamicSamplingContextFromScope(client, scope);\n  return [dynamicSamplingContext, traceContext];\n}\n\nfunction getActiveSpanWrapper(parentSpan) {\n  return parentSpan !== undefined\n    ? (callback) => {\n        return withActiveSpan(parentSpan, callback);\n      }\n    : (callback) => callback();\n}\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nfunction suppressTracing(callback) {\n  const ctx = core$1.suppressTracing(api.context.active());\n  return api.context.with(ctx, callback);\n}\n\n/** Ensure the `trace` context is set on all events. */\nfunction setupEventContextTrace(client) {\n  client.on('preprocessEvent', event => {\n    const span = getActiveSpan();\n    // For transaction events, this is handled separately\n    // Because the active span may not be the span that is actually the transaction event\n    if (!span || event.type === 'transaction') {\n      return;\n    }\n\n    // If event has already set `trace` context, use that one.\n    event.contexts = {\n      trace: core.spanToTraceContext(span),\n      ...event.contexts,\n    };\n\n    const rootSpan = core.getRootSpan(span);\n\n    event.sdkProcessingMetadata = {\n      dynamicSamplingContext: core.getDynamicSamplingContextFromSpan(rootSpan),\n      ...event.sdkProcessingMetadata,\n    };\n\n    return event;\n  });\n}\n\n/**\n * Otel-specific implementation of `getTraceData`.\n * @see `@sentry/core` version of `getTraceData` for more information\n */\nfunction getTraceData({\n  span,\n  scope,\n  client,\n} = {}) {\n  let ctx = (scope && getContextFromScope(scope)) ?? api.context.active();\n\n  if (span) {\n    const { scope } = core.getCapturedScopesOnSpan(span);\n    // fall back to current context if for whatever reason we can't find the one of the span\n    ctx = (scope && getContextFromScope(scope)) || api.trace.setSpan(api.context.active(), span);\n  }\n\n  const { traceId, spanId, sampled, dynamicSamplingContext } = getInjectionData(ctx, { scope, client });\n\n  return {\n    'sentry-trace': core.generateSentryTraceHeader(traceId, spanId, sampled),\n    baggage: core.dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext),\n  };\n}\n\n/**\n * Sets the async context strategy to use follow the OTEL context under the hood.\n * We handle forking a hub inside of our custom OTEL Context Manager (./otelContextManager.ts)\n */\nfunction setOpenTelemetryContextAsyncContextStrategy() {\n  function getScopes() {\n    const ctx = api.context.active();\n    const scopes = getScopesFromContext(ctx);\n\n    if (scopes) {\n      return scopes;\n    }\n\n    // fallback behavior:\n    // if, for whatever reason, we can't find scopes on the context here, we have to fix this somehow\n    return {\n      scope: core.getDefaultCurrentScope(),\n      isolationScope: core.getDefaultIsolationScope(),\n    };\n  }\n\n  function withScope(callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    // as by default, we don't want to fork this, unless triggered explicitly by `withScope`\n    return api.context.with(ctx, () => {\n      return callback(getCurrentScope());\n    });\n  }\n\n  function withSetScope(scope, callback) {\n    const ctx = getContextFromScope(scope) || api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_SET_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which picks up this scope as the current scope\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY, scope), () => {\n      return callback(scope);\n    });\n  }\n\n  function withIsolationScope(callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY, true), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function withSetIsolationScope(isolationScope, callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY, isolationScope), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function getCurrentScope() {\n    return getScopes().scope;\n  }\n\n  function getIsolationScope() {\n    return getScopes().isolationScope;\n  }\n\n  core.setAsyncContextStrategy({\n    withScope,\n    withSetScope,\n    withSetIsolationScope,\n    withIsolationScope,\n    getCurrentScope,\n    getIsolationScope,\n    startSpan,\n    startSpanManual,\n    startInactiveSpan,\n    getActiveSpan,\n    suppressTracing,\n    getTraceData,\n    continueTrace,\n    // The types here don't fully align, because our own `Span` type is narrower\n    // than the OTEL one - but this is OK for here, as we now we'll only have OTEL spans passed around\n    withActiveSpan: withActiveSpan ,\n  });\n}\n\n/**\n * Wrap an OpenTelemetry ContextManager in a way that ensures the context is kept in sync with the Sentry Scope.\n *\n * Usage:\n * import { AsyncLocalStorageContextManager } from '@opentelemetry/context-async-hooks';\n * const SentryContextManager = wrapContextManagerClass(AsyncLocalStorageContextManager);\n * const contextManager = new SentryContextManager();\n */\nfunction wrapContextManagerClass(\n  ContextManagerClass,\n) {\n  /**\n   * This is a custom ContextManager for OpenTelemetry, which extends the default AsyncLocalStorageContextManager.\n   * It ensures that we create new scopes per context, so that the OTEL Context & the Sentry Scope are always in sync.\n   *\n   * Note that we currently only support AsyncHooks with this,\n   * but since this should work for Node 14+ anyhow that should be good enough.\n   */\n\n  // @ts-expect-error TS does not like this, but we know this is fine\n  class SentryContextManager extends ContextManagerClass {\n     constructor(...args) {\n      super(...args);\n      setIsSetup('SentryContextManager');\n    }\n    /**\n     * Overwrite with() of the original AsyncLocalStorageContextManager\n     * to ensure we also create new scopes per context.\n     */\n     with(\n      context,\n      fn,\n      thisArg,\n      ...args\n    ) {\n      const currentScopes = getScopesFromContext(context);\n      const currentScope = currentScopes?.scope || core.getCurrentScope();\n      const currentIsolationScope = currentScopes?.isolationScope || core.getIsolationScope();\n\n      const shouldForkIsolationScope = context.getValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY) === true;\n      const scope = context.getValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY) ;\n      const isolationScope = context.getValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY) ;\n\n      const newCurrentScope = scope || currentScope.clone();\n      const newIsolationScope =\n        isolationScope || (shouldForkIsolationScope ? currentIsolationScope.clone() : currentIsolationScope);\n      const scopes = { scope: newCurrentScope, isolationScope: newIsolationScope };\n\n      const ctx1 = setScopesOnContext(context, scopes);\n\n      // Remove the unneeded values again\n      const ctx2 = ctx1\n        .deleteValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);\n\n      setContextOnScope(newCurrentScope, ctx2);\n\n      return super.with(ctx2, fn, thisArg, ...args);\n    }\n  }\n\n  return SentryContextManager ;\n}\n\n/**\n * This function runs through a list of OTEL Spans, and wraps them in an `SpanNode`\n * where each node holds a reference to their parent node.\n */\nfunction groupSpansWithParents(spans) {\n  const nodeMap = new Map();\n\n  for (const span of spans) {\n    createOrUpdateSpanNodeAndRefs(nodeMap, span);\n  }\n\n  return Array.from(nodeMap, function ([_id, spanNode]) {\n    return spanNode;\n  });\n}\n\n/**\n * This returns the _local_ parent ID - `parentId` on the span may point to a remote span.\n */\nfunction getLocalParentId(span) {\n  const parentIsRemote = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE] === true;\n  // If the parentId is the trace parent ID, we pretend it's undefined\n  // As this means the parent exists somewhere else\n  return !parentIsRemote ? getParentSpanId(span) : undefined;\n}\n\nfunction createOrUpdateSpanNodeAndRefs(nodeMap, span) {\n  const id = span.spanContext().spanId;\n  const parentId = getLocalParentId(span);\n\n  if (!parentId) {\n    createOrUpdateNode(nodeMap, { id, span, children: [] });\n    return;\n  }\n\n  // Else make sure to create parent node as well\n  // Note that the parent may not know it's parent _yet_, this may be updated in a later pass\n  const parentNode = createOrGetParentNode(nodeMap, parentId);\n  const node = createOrUpdateNode(nodeMap, { id, span, parentNode, children: [] });\n  parentNode.children.push(node);\n}\n\nfunction createOrGetParentNode(nodeMap, id) {\n  const existing = nodeMap.get(id);\n\n  if (existing) {\n    return existing;\n  }\n\n  return createOrUpdateNode(nodeMap, { id, children: [] });\n}\n\nfunction createOrUpdateNode(nodeMap, spanNode) {\n  const existing = nodeMap.get(spanNode.id);\n\n  // If span is already set, nothing to do here\n  if (existing?.span) {\n    return existing;\n  }\n\n  // If it exists but span is not set yet, we update it\n  if (existing && !existing.span) {\n    existing.span = spanNode.span;\n    existing.parentNode = spanNode.parentNode;\n    return existing;\n  }\n\n  // Else, we create a new one...\n  nodeMap.set(spanNode.id, spanNode);\n  return spanNode;\n}\n\n// canonicalCodesGrpcMap maps some GRPC codes to Sentry's span statuses. See description in grpc documentation.\nconst canonicalGrpcErrorCodesMap = {\n  '1': 'cancelled',\n  '2': 'unknown_error',\n  '3': 'invalid_argument',\n  '4': 'deadline_exceeded',\n  '5': 'not_found',\n  '6': 'already_exists',\n  '7': 'permission_denied',\n  '8': 'resource_exhausted',\n  '9': 'failed_precondition',\n  '10': 'aborted',\n  '11': 'out_of_range',\n  '12': 'unimplemented',\n  '13': 'internal_error',\n  '14': 'unavailable',\n  '15': 'data_loss',\n  '16': 'unauthenticated',\n} ;\n\nconst isStatusErrorMessageValid = (message) => {\n  return Object.values(canonicalGrpcErrorCodesMap).includes(message );\n};\n\n/**\n * Get a Sentry span status from an otel span.\n */\nfunction mapStatus(span) {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const status = spanHasStatus(span) ? span.status : undefined;\n\n  if (status) {\n    // Since span status OK is not set by default, we give it priority: https://opentelemetry.io/docs/concepts/signals/traces/#span-status\n    if (status.code === api.SpanStatusCode.OK) {\n      return { code: core.SPAN_STATUS_OK };\n      // If the span is already marked as erroneous we return that exact status\n    } else if (status.code === api.SpanStatusCode.ERROR) {\n      if (typeof status.message === 'undefined') {\n        const inferredStatus = inferStatusFromAttributes(attributes);\n        if (inferredStatus) {\n          return inferredStatus;\n        }\n      }\n\n      if (status.message && isStatusErrorMessageValid(status.message)) {\n        return { code: core.SPAN_STATUS_ERROR, message: status.message };\n      } else {\n        return { code: core.SPAN_STATUS_ERROR, message: 'unknown_error' };\n      }\n    }\n  }\n\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n  const inferredStatus = inferStatusFromAttributes(attributes);\n\n  if (inferredStatus) {\n    return inferredStatus;\n  }\n\n  // We default to setting the spans status to ok.\n  if (status?.code === api.SpanStatusCode.UNSET) {\n    return { code: core.SPAN_STATUS_OK };\n  } else {\n    return { code: core.SPAN_STATUS_ERROR, message: 'unknown_error' };\n  }\n}\n\nfunction inferStatusFromAttributes(attributes) {\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n\n  // eslint-disable-next-line deprecation/deprecation\n  const httpCodeAttribute = attributes[semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE] || attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE];\n  // eslint-disable-next-line deprecation/deprecation\n  const grpcCodeAttribute = attributes[semanticConventions.SEMATTRS_RPC_GRPC_STATUS_CODE];\n\n  const numberHttpCode =\n    typeof httpCodeAttribute === 'number'\n      ? httpCodeAttribute\n      : typeof httpCodeAttribute === 'string'\n        ? parseInt(httpCodeAttribute)\n        : undefined;\n\n  if (typeof numberHttpCode === 'number') {\n    return core.getSpanStatusFromHttpCode(numberHttpCode);\n  }\n\n  if (typeof grpcCodeAttribute === 'string') {\n    return { code: core.SPAN_STATUS_ERROR, message: canonicalGrpcErrorCodesMap[grpcCodeAttribute] || 'unknown_error' };\n  }\n\n  return undefined;\n}\n\nconst MAX_SPAN_COUNT = 1000;\nconst DEFAULT_TIMEOUT = 300; // 5 min\n\n/**\n * A Sentry-specific exporter that converts OpenTelemetry Spans to Sentry Spans & Transactions.\n */\nclass SentrySpanExporter {\n  /*\n   * A quick explanation on the buckets: We do bucketing of finished spans for efficiency. This span exporter is\n   * accumulating spans until a root span is encountered and then it flushes all the spans that are descendants of that\n   * root span. Because it is totally in the realm of possibilities that root spans are never finished, and we don't\n   * want to accumulate spans indefinitely in memory, we need to periodically evacuate spans. Naively we could simply\n   * store the spans in an array and each time a new span comes in we could iterate through the entire array and\n   * evacuate all spans that have an end-timestamp that is older than our limit. This could get quite expensive because\n   * we would have to iterate a potentially large number of spans every time we evacuate. We want to avoid these large\n   * bursts of computation.\n   *\n   * Instead we go for a bucketing approach and put spans into buckets, based on what second\n   * (modulo the time limit) the span was put into the exporter. With buckets, when we decide to evacuate, we can\n   * iterate through the bucket entries instead, which have an upper bound of items, making the evacuation much more\n   * efficient. Cleaning up also becomes much more efficient since it simply involves de-referencing a bucket within the\n   * bucket array, and letting garbage collection take care of the rest.\n   */\n\n  // Essentially a a set of span ids that are already sent. The values are expiration\n  // times in this cache so we don't hold onto them indefinitely.\n\n  /* Internally, we use a debounced flush to give some wiggle room to the span processor to accumulate more spans. */\n\n   constructor(options\n\n) {\n    this._finishedSpanBucketSize = options?.timeout || DEFAULT_TIMEOUT;\n    this._finishedSpanBuckets = new Array(this._finishedSpanBucketSize).fill(undefined);\n    this._lastCleanupTimestampInS = Math.floor(Date.now() / 1000);\n    this._spansToBucketEntry = new WeakMap();\n    this._sentSpans = new Map();\n    this._debouncedFlush = core.debounce(this.flush.bind(this), 1, { maxWait: 100 });\n  }\n\n  /**\n   * Export a single span.\n   * This is called by the span processor whenever a span is ended.\n   */\n   export(span) {\n    const currentTimestampInS = Math.floor(Date.now() / 1000);\n\n    if (this._lastCleanupTimestampInS !== currentTimestampInS) {\n      let droppedSpanCount = 0;\n      this._finishedSpanBuckets.forEach((bucket, i) => {\n        if (bucket && bucket.timestampInS <= currentTimestampInS - this._finishedSpanBucketSize) {\n          droppedSpanCount += bucket.spans.size;\n          this._finishedSpanBuckets[i] = undefined;\n        }\n      });\n      if (droppedSpanCount > 0) {\n        DEBUG_BUILD &&\n          core.debug.log(\n            `SpanExporter dropped ${droppedSpanCount} spans because they were pending for more than ${this._finishedSpanBucketSize} seconds.`,\n          );\n      }\n      this._lastCleanupTimestampInS = currentTimestampInS;\n    }\n\n    const currentBucketIndex = currentTimestampInS % this._finishedSpanBucketSize;\n    const currentBucket = this._finishedSpanBuckets[currentBucketIndex] || {\n      timestampInS: currentTimestampInS,\n      spans: new Set(),\n    };\n    this._finishedSpanBuckets[currentBucketIndex] = currentBucket;\n    currentBucket.spans.add(span);\n    this._spansToBucketEntry.set(span, currentBucket);\n\n    // If the span doesn't have a local parent ID (it's a root span), we're gonna flush all the ended spans\n    const localParentId = getLocalParentId(span);\n    if (!localParentId || this._sentSpans.has(localParentId)) {\n      this._debouncedFlush();\n    }\n  }\n\n  /**\n   * Try to flush any pending spans immediately.\n   * This is called internally by the exporter (via _debouncedFlush),\n   * but can also be triggered externally if we force-flush.\n   */\n   flush() {\n    const finishedSpans = this._finishedSpanBuckets.flatMap(bucket => (bucket ? Array.from(bucket.spans) : []));\n\n    this._flushSentSpanCache();\n    const sentSpans = this._maybeSend(finishedSpans);\n\n    const sentSpanCount = sentSpans.size;\n    const remainingOpenSpanCount = finishedSpans.length - sentSpanCount;\n    DEBUG_BUILD &&\n      core.debug.log(\n        `SpanExporter exported ${sentSpanCount} spans, ${remainingOpenSpanCount} spans are waiting for their parent spans to finish`,\n      );\n\n    const expirationDate = Date.now() + DEFAULT_TIMEOUT * 1000;\n\n    for (const span of sentSpans) {\n      this._sentSpans.set(span.spanContext().spanId, expirationDate);\n      const bucketEntry = this._spansToBucketEntry.get(span);\n      if (bucketEntry) {\n        bucketEntry.spans.delete(span);\n      }\n    }\n    // Cancel a pending debounced flush, if there is one\n    // This can be relevant if we directly flush, circumventing the debounce\n    // in that case, we want to cancel any pending debounced flush\n    this._debouncedFlush.cancel();\n  }\n\n  /**\n   * Clear the exporter.\n   * This is called when the span processor is shut down.\n   */\n   clear() {\n    this._finishedSpanBuckets = this._finishedSpanBuckets.fill(undefined);\n    this._sentSpans.clear();\n    this._debouncedFlush.cancel();\n  }\n\n  /**\n   * Send the given spans, but only if they are part of a finished transaction.\n   *\n   * Returns the sent spans.\n   * Spans remain unsent when their parent span is not yet finished.\n   * This will happen regularly, as child spans are generally finished before their parents.\n   * But it _could_ also happen because, for whatever reason, a parent span was lost.\n   * In this case, we'll eventually need to clean this up.\n   */\n   _maybeSend(spans) {\n    const grouped = groupSpansWithParents(spans);\n    const sentSpans = new Set();\n\n    const rootNodes = this._getCompletedRootNodes(grouped);\n\n    for (const root of rootNodes) {\n      const span = root.span;\n      sentSpans.add(span);\n      const transactionEvent = createTransactionForOtelSpan(span);\n\n      // Add an attribute to the transaction event to indicate that this transaction is an orphaned transaction\n      if (root.parentNode && this._sentSpans.has(root.parentNode.id)) {\n        const traceData = transactionEvent.contexts?.trace?.data;\n        if (traceData) {\n          traceData['sentry.parent_span_already_sent'] = true;\n        }\n      }\n\n      // We'll recursively add all the child spans to this array\n      const spans = transactionEvent.spans || [];\n\n      for (const child of root.children) {\n        createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n      }\n\n      // spans.sort() mutates the array, but we do not use this anymore after this point\n      // so we can safely mutate it here\n      transactionEvent.spans =\n        spans.length > MAX_SPAN_COUNT\n          ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT)\n          : spans;\n\n      const measurements = core.timedEventsToMeasurements(span.events);\n      if (measurements) {\n        transactionEvent.measurements = measurements;\n      }\n\n      core.captureEvent(transactionEvent);\n    }\n\n    return sentSpans;\n  }\n\n  /** Remove \"expired\" span id entries from the _sentSpans cache. */\n   _flushSentSpanCache() {\n    const currentTimestamp = Date.now();\n    // Note, it is safe to delete items from the map as we go: https://stackoverflow.com/a/35943995/90297\n    for (const [spanId, expirationTime] of this._sentSpans.entries()) {\n      if (expirationTime <= currentTimestamp) {\n        this._sentSpans.delete(spanId);\n      }\n    }\n  }\n\n  /** Check if a node is a completed root node or a node whose parent has already been sent */\n   _nodeIsCompletedRootNodeOrHasSentParent(node) {\n    return !!node.span && (!node.parentNode || this._sentSpans.has(node.parentNode.id));\n  }\n\n  /** Get all completed root nodes from a list of nodes */\n   _getCompletedRootNodes(nodes) {\n    // TODO: We should be able to remove the explicit `node is SpanNodeCompleted` type guard\n    //       once we stop supporting TS < 5.5\n    return nodes.filter((node) => this._nodeIsCompletedRootNodeOrHasSentParent(node));\n  }\n}\n\nfunction parseSpan(span) {\n  const attributes = span.attributes;\n\n  const origin = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] ;\n  const op = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] ;\n  const source = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ;\n\n  return { origin, op, source };\n}\n\n/** Exported only for tests. */\nfunction createTransactionForOtelSpan(span) {\n  const { op, description, data, origin = 'manual', source } = getSpanData(span);\n  const capturedSpanScopes = core.getCapturedScopesOnSpan(span );\n\n  const sampleRate = span.attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ;\n\n  const attributes = {\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    ...data,\n    ...removeSentryAttributes(span.attributes),\n  };\n\n  const { links } = span;\n  const { traceId: trace_id, spanId: span_id } = span.spanContext();\n\n  // If parentSpanIdFromTraceState is defined at all, we want it to take precedence\n  // In that case, an empty string should be interpreted as \"no parent span id\",\n  // even if `span.parentSpanId` is set\n  // this is the case when we are starting a new trace, where we have a virtual span based on the propagationContext\n  // We only want to continue the traceId in this case, but ignore the parent span\n  const parent_span_id = getParentSpanId(span);\n\n  const status = mapStatus(span);\n\n  const traceContext = {\n    parent_span_id,\n    span_id,\n    trace_id,\n    data: attributes,\n    origin,\n    op,\n    status: core.getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    links: core.convertSpanLinksForEnvelope(links),\n  };\n\n  const statusCode = attributes[semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE];\n  const responseContext = typeof statusCode === 'number' ? { response: { status_code: statusCode } } : undefined;\n\n  const transactionEvent = {\n    contexts: {\n      trace: traceContext,\n      otel: {\n        resource: span.resource.attributes,\n      },\n      ...responseContext,\n    },\n    spans: [],\n    start_timestamp: core.spanTimeInputToSeconds(span.startTime),\n    timestamp: core.spanTimeInputToSeconds(span.endTime),\n    transaction: description,\n    type: 'transaction',\n    sdkProcessingMetadata: {\n      capturedSpanScope: capturedSpanScopes.scope,\n      capturedSpanIsolationScope: capturedSpanScopes.isolationScope,\n      sampleRate,\n      dynamicSamplingContext: core.getDynamicSamplingContextFromSpan(span ),\n    },\n    ...(source && {\n      transaction_info: {\n        source,\n      },\n    }),\n  };\n\n  return transactionEvent;\n}\n\nfunction createAndFinishSpanForOtelSpan(node, spans, sentSpans) {\n  const span = node.span;\n\n  if (span) {\n    sentSpans.add(span);\n  }\n\n  const shouldDrop = !span;\n\n  // If this span should be dropped, we still want to create spans for the children of this\n  if (shouldDrop) {\n    node.children.forEach(child => {\n      createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n    });\n    return;\n  }\n\n  const span_id = span.spanContext().spanId;\n  const trace_id = span.spanContext().traceId;\n  const parentSpanId = getParentSpanId(span);\n\n  const { attributes, startTime, endTime, links } = span;\n\n  const { op, description, data, origin = 'manual' } = getSpanData(span);\n  const allData = {\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    ...removeSentryAttributes(attributes),\n    ...data,\n  };\n\n  const status = mapStatus(span);\n\n  const spanJSON = {\n    span_id,\n    trace_id,\n    data: allData,\n    description,\n    parent_span_id: parentSpanId,\n    start_timestamp: core.spanTimeInputToSeconds(startTime),\n    // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n    timestamp: core.spanTimeInputToSeconds(endTime) || undefined,\n    status: core.getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    op,\n    origin,\n    measurements: core.timedEventsToMeasurements(span.events),\n    links: core.convertSpanLinksForEnvelope(links),\n  };\n\n  spans.push(spanJSON);\n\n  node.children.forEach(child => {\n    createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n  });\n}\n\nfunction getSpanData(span)\n\n {\n  const { op: definedOp, source: definedSource, origin } = parseSpan(span);\n  const { op: inferredOp, description, source: inferredSource, data: inferredData } = parseSpanDescription(span);\n\n  const op = definedOp || inferredOp;\n  const source = definedSource || inferredSource;\n\n  const data = { ...inferredData, ...getData(span) };\n\n  return {\n    op,\n    description,\n    source,\n    origin,\n    data,\n  };\n}\n\n/**\n * Remove custom `sentry.` attributes we do not need to send.\n * These are more carrier attributes we use inside of the SDK, we do not need to send them to the API.\n */\nfunction removeSentryAttributes(data) {\n  const cleanedData = { ...data };\n\n  /* eslint-disable @typescript-eslint/no-dynamic-delete */\n  delete cleanedData[core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE];\n  delete cleanedData[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n  /* eslint-enable @typescript-eslint/no-dynamic-delete */\n\n  return cleanedData;\n}\n\nfunction getData(span) {\n  const attributes = span.attributes;\n  const data = {};\n\n  if (span.kind !== api.SpanKind.INTERNAL) {\n    data['otel.kind'] = api.SpanKind[span.kind];\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const maybeHttpStatusCodeAttribute = attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE];\n  if (maybeHttpStatusCodeAttribute) {\n    data[semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE] = maybeHttpStatusCodeAttribute ;\n  }\n\n  const requestData = getRequestSpanData(span);\n\n  if (requestData.url) {\n    data.url = requestData.url;\n  }\n\n  if (requestData['http.query']) {\n    data['http.query'] = requestData['http.query'].slice(1);\n  }\n  if (requestData['http.fragment']) {\n    data['http.fragment'] = requestData['http.fragment'].slice(1);\n  }\n\n  return data;\n}\n\nfunction onSpanStart(span, parentContext) {\n  // This is a reliable way to get the parent span - because this is exactly how the parent is identified in the OTEL SDK\n  const parentSpan = api.trace.getSpan(parentContext);\n\n  let scopes = getScopesFromContext(parentContext);\n\n  // We need access to the parent span in order to be able to move up the span tree for breadcrumbs\n  if (parentSpan && !parentSpan.spanContext().isRemote) {\n    core.addChildSpanToSpan(parentSpan, span);\n  }\n\n  // We need this in the span exporter\n  if (parentSpan?.spanContext().isRemote) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE, true);\n  }\n\n  // The root context does not have scopes stored, so we check for this specifically\n  // As fallback we attach the global scopes\n  if (parentContext === api.ROOT_CONTEXT) {\n    scopes = {\n      scope: core.getDefaultCurrentScope(),\n      isolationScope: core.getDefaultIsolationScope(),\n    };\n  }\n\n  // We need the scope at time of span creation in order to apply it to the event when the span is finished\n  if (scopes) {\n    core.setCapturedScopesOnSpan(span, scopes.scope, scopes.isolationScope);\n  }\n\n  core.logSpanStart(span);\n\n  const client = core.getClient();\n  client?.emit('spanStart', span);\n}\n\nfunction onSpanEnd(span) {\n  core.logSpanEnd(span);\n\n  const client = core.getClient();\n  client?.emit('spanEnd', span);\n}\n\n/**\n * Converts OpenTelemetry Spans to Sentry Spans and sends them to Sentry via\n * the Sentry SDK.\n */\nclass SentrySpanProcessor  {\n\n   constructor(options) {\n    setIsSetup('SentrySpanProcessor');\n    this._exporter = new SentrySpanExporter(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   async forceFlush() {\n    this._exporter.flush();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   async shutdown() {\n    this._exporter.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   onStart(span, parentContext) {\n    onSpanStart(span, parentContext);\n  }\n\n  /** @inheritDoc */\n   onEnd(span) {\n    onSpanEnd(span);\n\n    this._exporter.export(span);\n  }\n}\n\n/**\n * A custom OTEL sampler that uses Sentry sampling rates to make its decision\n */\nclass SentrySampler  {\n\n   constructor(client) {\n    this._client = client;\n    setIsSetup('SentrySampler');\n  }\n\n  /** @inheritDoc */\n   shouldSample(\n    context,\n    traceId,\n    spanName,\n    spanKind,\n    spanAttributes,\n    _links,\n  ) {\n    const options = this._client.getOptions();\n\n    const parentSpan = getValidSpan(context);\n    const parentContext = parentSpan?.spanContext();\n\n    if (!core.hasSpansEnabled(options)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    // `ATTR_HTTP_REQUEST_METHOD` is the new attribute, but we still support the old one, `SEMATTRS_HTTP_METHOD`, for now.\n    // eslint-disable-next-line deprecation/deprecation\n    const maybeSpanHttpMethod = spanAttributes[semanticConventions.SEMATTRS_HTTP_METHOD] || spanAttributes[semanticConventions.ATTR_HTTP_REQUEST_METHOD];\n\n    // If we have a http.client span that has no local parent, we never want to sample it\n    // but we want to leave downstream sampling decisions up to the server\n    if (spanKind === api.SpanKind.CLIENT && maybeSpanHttpMethod && (!parentSpan || parentContext?.isRemote)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const parentSampled = parentSpan ? getParentSampled(parentSpan, traceId, spanName) : undefined;\n    const isRootSpan = !parentSpan || parentContext?.isRemote;\n\n    // We only sample based on parameters (like tracesSampleRate or tracesSampler) for root spans (which is done in sampleSpan).\n    // Non-root-spans simply inherit the sampling decision from their parent.\n    if (!isRootSpan) {\n      return wrapSamplingDecision({\n        decision: parentSampled ? sdkTraceBase.SamplingDecision.RECORD_AND_SAMPLED : sdkTraceBase.SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n      });\n    }\n\n    // We want to pass the inferred name & attributes to the sampler method\n    const {\n      description: inferredSpanName,\n      data: inferredAttributes,\n      op,\n    } = inferSpanData(spanName, spanAttributes, spanKind);\n\n    const mergedAttributes = {\n      ...inferredAttributes,\n      ...spanAttributes,\n    };\n\n    if (op) {\n      mergedAttributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] = op;\n    }\n\n    const mutableSamplingDecision = { decision: true };\n    this._client.emit(\n      'beforeSampling',\n      {\n        spanAttributes: mergedAttributes,\n        spanName: inferredSpanName,\n        parentSampled: parentSampled,\n        parentContext: parentContext,\n      },\n      mutableSamplingDecision,\n    );\n    if (!mutableSamplingDecision.decision) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const { isolationScope } = getScopesFromContext(context) ?? {};\n\n    const dscString = parentContext?.traceState ? parentContext.traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n    const dsc = dscString ? core.baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n    const sampleRand = core.parseSampleRate(dsc?.sample_rand) ?? Math.random();\n\n    const [sampled, sampleRate, localSampleRateWasApplied] = core.sampleSpan(\n      options,\n      {\n        name: inferredSpanName,\n        attributes: mergedAttributes,\n        normalizedRequest: isolationScope?.getScopeData().sdkProcessingMetadata.normalizedRequest,\n        parentSampled,\n        parentSampleRate: core.parseSampleRate(dsc?.sample_rate),\n      },\n      sampleRand,\n    );\n\n    const method = `${maybeSpanHttpMethod}`.toUpperCase();\n    if (method === 'OPTIONS' || method === 'HEAD') {\n      DEBUG_BUILD && core.debug.log(`[Tracing] Not sampling span because HTTP method is '${method}' for ${spanName}`);\n\n      return wrapSamplingDecision({\n        decision: sdkTraceBase.SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n        sampleRand,\n        downstreamTraceSampleRate: 0, // we don't want to sample anything in the downstream trace either\n      });\n    }\n\n    if (\n      !sampled &&\n      // We check for `parentSampled === undefined` because we only want to record client reports for spans that are trace roots (ie. when there was incoming trace)\n      parentSampled === undefined\n    ) {\n      DEBUG_BUILD && core.debug.log('[Tracing] Discarding root span because its trace was not chosen to be sampled.');\n      this._client.recordDroppedEvent('sample_rate', 'transaction');\n    }\n\n    return {\n      ...wrapSamplingDecision({\n        decision: sampled ? sdkTraceBase.SamplingDecision.RECORD_AND_SAMPLED : sdkTraceBase.SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n        sampleRand,\n        downstreamTraceSampleRate: localSampleRateWasApplied ? sampleRate : undefined,\n      }),\n      attributes: {\n        // We set the sample rate on the span when a local sample rate was applied to better understand how traces were sampled in Sentry\n        [core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: localSampleRateWasApplied ? sampleRate : undefined,\n      },\n    };\n  }\n\n  /** Returns the sampler name or short description with the configuration. */\n   toString() {\n    return 'SentrySampler';\n  }\n}\n\nfunction getParentSampled(parentSpan, traceId, spanName) {\n  const parentContext = parentSpan.spanContext();\n\n  // Only inherit sample rate if `traceId` is the same\n  // Note for testing: `isSpanContextValid()` checks the format of the traceId/spanId, so we need to pass valid ones\n  if (api.isSpanContextValid(parentContext) && parentContext.traceId === traceId) {\n    if (parentContext.isRemote) {\n      const parentSampled = getSamplingDecision(parentSpan.spanContext());\n      DEBUG_BUILD &&\n        core.debug.log(`[Tracing] Inheriting remote parent's sampled decision for ${spanName}: ${parentSampled}`);\n      return parentSampled;\n    }\n\n    const parentSampled = getSamplingDecision(parentContext);\n    DEBUG_BUILD && core.debug.log(`[Tracing] Inheriting parent's sampled decision for ${spanName}: ${parentSampled}`);\n    return parentSampled;\n  }\n\n  return undefined;\n}\n\n/**\n * Wrap a sampling decision with data that Sentry needs to work properly with it.\n * If you pass `decision: undefined`, it will be treated as `NOT_RECORDING`, but in contrast to passing `NOT_RECORDING`\n * it will not propagate this decision to downstream Sentry SDKs.\n */\nfunction wrapSamplingDecision({\n  decision,\n  context,\n  spanAttributes,\n  sampleRand,\n  downstreamTraceSampleRate,\n}\n\n) {\n  let traceState = getBaseTraceState(context, spanAttributes);\n\n  // We will override the propagated sample rate downstream when\n  // - the tracesSampleRate is applied\n  // - the tracesSampler is invoked\n  // Since unsampled OTEL spans (NonRecordingSpans) cannot hold attributes we need to store this on the (trace)context.\n  if (downstreamTraceSampleRate !== undefined) {\n    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RATE, `${downstreamTraceSampleRate}`);\n  }\n\n  if (sampleRand !== undefined) {\n    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RAND, `${sampleRand}`);\n  }\n\n  // If the decision is undefined, we treat it as NOT_RECORDING, but we don't propagate this decision to downstream SDKs\n  // Which is done by not setting `SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING` traceState\n  if (decision == undefined) {\n    return { decision: sdkTraceBase.SamplingDecision.NOT_RECORD, traceState };\n  }\n\n  if (decision === sdkTraceBase.SamplingDecision.NOT_RECORD) {\n    return { decision, traceState: traceState.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') };\n  }\n\n  return { decision, traceState };\n}\n\nfunction getBaseTraceState(context, spanAttributes) {\n  const parentSpan = api.trace.getSpan(context);\n  const parentContext = parentSpan?.spanContext();\n\n  let traceState = parentContext?.traceState || new core$1.TraceState();\n\n  // We always keep the URL on the trace state, so we can access it in the propagator\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `ATTR_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const url = spanAttributes[semanticConventions.SEMATTRS_HTTP_URL] || spanAttributes[semanticConventions.ATTR_URL_FULL];\n  if (url && typeof url === 'string') {\n    traceState = traceState.set(SENTRY_TRACE_STATE_URL, url);\n  }\n\n  return traceState;\n}\n\n/**\n * If the active span is invalid, we want to ignore it as parent.\n * This aligns with how otel tracers and default samplers handle these cases.\n */\nfunction getValidSpan(context) {\n  const span = api.trace.getSpan(context);\n  return span && api.isSpanContextValid(span.spanContext()) ? span : undefined;\n}\n\nexports.getClient = core.getClient;\nexports.getDynamicSamplingContextFromSpan = core.getDynamicSamplingContextFromSpan;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION;\nexports.SentryPropagator = SentryPropagator;\nexports.SentrySampler = SentrySampler;\nexports.SentrySpanProcessor = SentrySpanProcessor;\nexports.continueTrace = continueTrace;\nexports.enhanceDscWithOpenTelemetryRootSpanName = enhanceDscWithOpenTelemetryRootSpanName;\nexports.getActiveSpan = getActiveSpan;\nexports.getRequestSpanData = getRequestSpanData;\nexports.getScopesFromContext = getScopesFromContext;\nexports.getSpanKind = getSpanKind;\nexports.getTraceContextForScope = getTraceContextForScope;\nexports.isSentryRequestSpan = isSentryRequestSpan;\nexports.openTelemetrySetupCheck = openTelemetrySetupCheck;\nexports.setOpenTelemetryContextAsyncContextStrategy = setOpenTelemetryContextAsyncContextStrategy;\nexports.setupEventContextTrace = setupEventContextTrace;\nexports.shouldPropagateTraceForUrl = shouldPropagateTraceForUrl;\nexports.spanHasAttributes = spanHasAttributes;\nexports.spanHasEvents = spanHasEvents;\nexports.spanHasKind = spanHasKind;\nexports.spanHasName = spanHasName;\nexports.spanHasParentId = spanHasParentId;\nexports.spanHasStatus = spanHasStatus;\nexports.startInactiveSpan = startInactiveSpan;\nexports.startSpan = startSpan;\nexports.startSpanManual = startSpanManual;\nexports.suppressTracing = suppressTracing;\nexports.withActiveSpan = withActiveSpan;\nexports.wrapClientClass = wrapClientClass;\nexports.wrapContextManagerClass = wrapContextManagerClass;\nexports.wrapSamplingDecision = wrapSamplingDecision;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlbnRyeStvcGVudGVsZW1ldHJ5QDEwLjE2XzZhYjQyMTQ1NmUyZjBiZjA0YzY2YzE0ZjU0OTg1ZmUxL25vZGVfbW9kdWxlcy9Ac2VudHJ5L29wZW50ZWxlbWV0cnkvYnVpbGQvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxpQkFBaUI7O0FBRXRFLDRCQUE0QixtQkFBTyxDQUFDLHNMQUFxQztBQUN6RSxhQUFhLG1CQUFPLENBQUMsa0hBQWM7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLGtJQUFvQjtBQUN4QyxlQUFlLG1CQUFPLENBQUMsOEpBQXFCO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLDRMQUErQjs7QUFFNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsYUFBYTs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5Qjs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtDQUFrQztBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLDBDQUEwQzs7QUFFcEQ7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsWUFBWSxFQUFFLFFBQVE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCLEdBQUcsa0VBQWtFO0FBQy9GOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLHNCQUFzQjtBQUNoQyxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGdCQUFnQiw4QkFBOEIsS0FBSyxrQkFBa0I7QUFDckU7QUFDQTs7QUFFQSxZQUFZLEtBQUs7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxjQUFjLDZEQUE2RDtBQUN2RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RkFBeUY7O0FBRXpGLFlBQVksbURBQW1EOztBQUUvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0JBQStCLEVBQUUsT0FBTyxLQUFLLGlCQUFpQjtBQUM3RjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJFQUEyRSxzQkFBc0I7QUFDakc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQjtBQUNBOztBQUVBLFVBQVUsc0NBQXNDOztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usd0JBQXdCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHFDQUFxQzs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHFDQUFxQzs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUscUNBQXFDOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSx5Q0FBeUM7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsa0JBQWtCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxtREFBbUQsMEJBQTBCLGVBQWU7O0FBRXRHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0NBQW9DO0FBQ2pGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLGtCQUFrQjtBQUN6RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsY0FBYztBQUNuRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQixnREFBZ0QsOEJBQThCO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZSxTQUFTLHdCQUF3QjtBQUNqRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxtREFBbUQ7QUFDN0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxxQ0FBcUM7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RCxZQUFZLDRCQUE0Qjs7QUFFckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSx3Q0FBd0M7O0FBRWxELFVBQVUsMkNBQTJDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBLFVBQVUsK0NBQStDO0FBQ3pELFVBQVUsMEVBQTBFOztBQUVwRjtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsOENBQThDO0FBQ2xGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOENBQThDO0FBQ2xGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOENBQThDO0FBQ2xGOztBQUVBLFlBQVksaUJBQWlCOztBQUU3QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0EsMkZBQTJGLE9BQU8sUUFBUSxTQUFTOztBQUVuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLFNBQVMsSUFBSSxjQUFjO0FBQy9HO0FBQ0E7O0FBRUE7QUFDQSx3RkFBd0YsU0FBUyxJQUFJLGNBQWM7QUFDbkg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsMEJBQTBCO0FBQzdGOztBQUVBO0FBQ0EsbUVBQW1FLFdBQVc7QUFDOUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQix5Q0FBeUM7QUFDekMsbURBQW1EO0FBQ25ELHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCLHFCQUFxQjtBQUNyQiwrQ0FBK0M7QUFDL0MscUJBQXFCO0FBQ3JCLDBCQUEwQjtBQUMxQiw0QkFBNEI7QUFDNUIsbUJBQW1CO0FBQ25CLCtCQUErQjtBQUMvQiwyQkFBMkI7QUFDM0IsK0JBQStCO0FBQy9CLG1EQUFtRDtBQUNuRCw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6QixpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLCtCQUErQjtBQUMvQiw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVmlzaExhcFxcQ3VyZThcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBzZW50cnkrb3BlbnRlbGVtZXRyeUAxMC4xNl82YWI0MjE0NTZlMmYwYmYwNGM2NmMxNGY1NDk4NWZlMVxcbm9kZV9tb2R1bGVzXFxAc2VudHJ5XFxvcGVudGVsZW1ldHJ5XFxidWlsZFxcY2pzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuY29uc3Qgc2VtYW50aWNDb252ZW50aW9ucyA9IHJlcXVpcmUoJ0BvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zJyk7XG5jb25zdCBjb3JlID0gcmVxdWlyZSgnQHNlbnRyeS9jb3JlJyk7XG5jb25zdCBhcGkgPSByZXF1aXJlKCdAb3BlbnRlbGVtZXRyeS9hcGknKTtcbmNvbnN0IGNvcmUkMSA9IHJlcXVpcmUoJ0BvcGVudGVsZW1ldHJ5L2NvcmUnKTtcbmNvbnN0IHNka1RyYWNlQmFzZSA9IHJlcXVpcmUoJ0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlJyk7XG5cbi8qKiBJZiB0aGlzIGF0dHJpYnV0ZSBpcyB0cnVlLCBpdCBtZWFucyB0aGF0IHRoZSBwYXJlbnQgaXMgYSByZW1vdGUgc3Bhbi4gKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUEFSRU5UX0lTX1JFTU9URSA9ICdzZW50cnkucGFyZW50SXNSZW1vdGUnO1xuXG4vLyBUaGVzZSBhcmUgbm90IHN0YW5kYXJkaXplZCB5ZXQsIGJ1dCB1c2VkIGJ5IHRoZSBncmFwaHFsIGluc3RydW1lbnRhdGlvblxuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9HUkFQSFFMX09QRVJBVElPTiA9ICdzZW50cnkuZ3JhcGhxbC5vcGVyYXRpb24nO1xuXG4vKipcbiAqIEdldCB0aGUgcGFyZW50IHNwYW4gaWQgZnJvbSBhIHNwYW4uXG4gKiBJbiBPVGVsIHYxLCB0aGUgcGFyZW50IHNwYW4gaWQgaXMgYWNjZXNzZWQgYXMgYHBhcmVudFNwYW5JZGBcbiAqIEluIE9UZWwgdjIsIHRoZSBwYXJlbnQgc3BhbiBpZCBpcyBhY2Nlc3NlZCBhcyBgc3BhbklkYCBvbiB0aGUgYHBhcmVudFNwYW5Db250ZXh0YFxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRTcGFuSWQoc3Bhbikge1xuICBpZiAoJ3BhcmVudFNwYW5JZCcgaW4gc3Bhbikge1xuICAgIHJldHVybiBzcGFuLnBhcmVudFNwYW5JZCA7XG4gIH0gZWxzZSBpZiAoJ3BhcmVudFNwYW5Db250ZXh0JyBpbiBzcGFuKSB7XG4gICAgcmV0dXJuIChzcGFuLnBhcmVudFNwYW5Db250ZXh0ICk/LnNwYW5JZDtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBhdHRyaWJ1dGVzLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYmFzZSBgU3BhbmAgdHlwZSBkb2VzIG5vdCBoYXZlIGF0dHJpYnV0ZXMsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyB0aGVtLlxuICovXG5mdW5jdGlvbiBzcGFuSGFzQXR0cmlidXRlcyhcbiAgc3Bhbixcbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gISFjYXN0U3Bhbi5hdHRyaWJ1dGVzICYmIHR5cGVvZiBjYXN0U3Bhbi5hdHRyaWJ1dGVzID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHNwYW4gaGFzIGEga2luZC5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJhc2UgYFNwYW5gIHR5cGUgZG9lcyBub3QgaGF2ZSBhIGtpbmQsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyBpdC5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc0tpbmQoc3Bhbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gdHlwZW9mIGNhc3RTcGFuLmtpbmQgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gc3BhbiBoYXMgYSBzdGF0dXMuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgYSBzdGF0dXMsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyBpdC5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc1N0YXR1cyhcbiAgc3Bhbixcbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gISFjYXN0U3Bhbi5zdGF0dXM7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBhIG5hbWUuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgYSBuYW1lLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgaXQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNOYW1lKHNwYW4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuICEhY2FzdFNwYW4ubmFtZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHNwYW4gaGFzIGEga2luZC5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJhc2UgYFNwYW5gIHR5cGUgZG9lcyBub3QgaGF2ZSBhIGtpbmQsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyBpdC5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc1BhcmVudElkKFxuICBzcGFuLFxuKSB7XG4gIGNvbnN0IGNhc3RTcGFuID0gc3BhbiA7XG4gIHJldHVybiAhIWdldFBhcmVudFNwYW5JZChjYXN0U3Bhbik7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBldmVudHMuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgZXZlbnRzLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgaXQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNFdmVudHMoXG4gIHNwYW4sXG4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY2FzdFNwYW4uZXZlbnRzKTtcbn1cblxuLyoqXG4gKiBHZXQgc2FuaXRpemllZCByZXF1ZXN0IGRhdGEgZnJvbSBhbiBPVEVMIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIGdldFJlcXVlc3RTcGFuRGF0YShzcGFuKSB7XG4gIC8vIFRoZSBiYXNlIGBTcGFuYCB0eXBlIGhhcyBubyBgYXR0cmlidXRlc2AsIHNvIHdlIG5lZWQgdG8gZ3VhcmQgaGVyZSBhZ2FpbnN0IHRoYXRcbiAgaWYgKCFzcGFuSGFzQXR0cmlidXRlcyhzcGFuKSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBtYXliZVVybEF0dHJpYnV0ZSA9IChzcGFuLmF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX1VSTF9GVUxMXSB8fCBzcGFuLmF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1VSTF0pXG5cbjtcblxuICBjb25zdCBkYXRhID0ge1xuICAgIHVybDogbWF5YmVVcmxBdHRyaWJ1dGUsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgJ2h0dHAubWV0aG9kJzogKHNwYW4uYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF0gfHwgc3Bhbi5hdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9NRVRIT0RdKVxuXG4sXG4gIH07XG5cbiAgLy8gRGVmYXVsdCB0byBHRVQgaWYgVVJMIGlzIHNldCBidXQgbWV0aG9kIGlzIG5vdFxuICBpZiAoIWRhdGFbJ2h0dHAubWV0aG9kJ10gJiYgZGF0YS51cmwpIHtcbiAgICBkYXRhWydodHRwLm1ldGhvZCddID0gJ0dFVCc7XG4gIH1cblxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgbWF5YmVVcmxBdHRyaWJ1dGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB1cmwgPSBjb3JlLnBhcnNlVXJsKG1heWJlVXJsQXR0cmlidXRlKTtcblxuICAgICAgZGF0YS51cmwgPSBjb3JlLmdldFNhbml0aXplZFVybFN0cmluZyh1cmwpO1xuXG4gICAgICBpZiAodXJsLnNlYXJjaCkge1xuICAgICAgICBkYXRhWydodHRwLnF1ZXJ5J10gPSB1cmwuc2VhcmNoO1xuICAgICAgfVxuICAgICAgaWYgKHVybC5oYXNoKSB7XG4gICAgICAgIGRhdGFbJ2h0dHAuZnJhZ21lbnQnXSA9IHVybC5oYXNoO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gaWdub3JlXG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gVHlwZXNjcmlwdCBjb21wbGFpbnMgaWYgd2UgZG8gbm90IHVzZSBgLi4uYXJnczogYW55W11gIGZvciB0aGUgbWl4aW4sIHdpdGg6XG4vLyBBIG1peGluIGNsYXNzIG11c3QgaGF2ZSBhIGNvbnN0cnVjdG9yIHdpdGggYSBzaW5nbGUgcmVzdCBwYXJhbWV0ZXIgb2YgdHlwZSAnYW55W10nLnRzKDI1NDUpXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cbi8qKlxuICogV3JhcCBhbiBDbGllbnQgY2xhc3Mgd2l0aCB0aGluZ3Mgd2UgbmVlZCBmb3IgT3BlblRlbGVtZXRyeSBzdXBwb3J0LlxuICogTWFrZSBzdXJlIHRoYXQgdGhlIENsaWVudCBjbGFzcyBwYXNzZWQgaW4gaXMgbm9uLWFic3RyYWN0IVxuICpcbiAqIFVzYWdlOlxuICogY29uc3QgT3BlblRlbGVtZXRyeUNsaWVudCA9IGdldFdyYXBwZWRDbGllbnRDbGFzcyhOb2RlQ2xpZW50KTtcbiAqIGNvbnN0IGNsaWVudCA9IG5ldyBPcGVuVGVsZW1ldHJ5Q2xpZW50KG9wdGlvbnMpO1xuICovXG5mdW5jdGlvbiB3cmFwQ2xpZW50Q2xhc3NcblxuKENsaWVudENsYXNzKSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgV2UganVzdCBhc3N1bWUgdGhhdCB0aGlzIGlzIG5vbi1hYnN0cmFjdCwgaWYgeW91IHBhc3MgaW4gYW4gYWJzdHJhY3QgY2xhc3MgdGhpcyB3b3VsZCBtYWtlIGl0IG5vbi1hYnN0cmFjdFxuICBjbGFzcyBPcGVuVGVsZW1ldHJ5Q2xpZW50IGV4dGVuZHMgQ2xpZW50Q2xhc3MgIHtcblxuICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHRoZSBPVEVMIHRyYWNlci4gKi9cbiAgICAgZ2V0IHRyYWNlcigpIHtcbiAgICAgIGlmICh0aGlzLl90cmFjZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNlcjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmFtZSA9ICdAc2VudHJ5L29wZW50ZWxlbWV0cnknO1xuICAgICAgY29uc3QgdmVyc2lvbiA9IGNvcmUuU0RLX1ZFUlNJT047XG4gICAgICBjb25zdCB0cmFjZXIgPSBhcGkudHJhY2UuZ2V0VHJhY2VyKG5hbWUsIHZlcnNpb24pO1xuICAgICAgdGhpcy5fdHJhY2VyID0gdHJhY2VyO1xuXG4gICAgICByZXR1cm4gdHJhY2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgIGFzeW5jIGZsdXNoKHRpbWVvdXQpIHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy50cmFjZVByb3ZpZGVyO1xuICAgICAgYXdhaXQgcHJvdmlkZXI/LmZvcmNlRmx1c2goKTtcbiAgICAgIHJldHVybiBzdXBlci5mbHVzaCh0aW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gT3BlblRlbGVtZXRyeUNsaWVudCA7XG59XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblxuLyoqXG4gKiBHZXQgdGhlIHNwYW4ga2luZCBmcm9tIGEgc3Bhbi5cbiAqIEZvciB3aGF0ZXZlciByZWFzb24sIHRoaXMgaXMgbm90IHB1YmxpYyBBUEkgb24gdGhlIGdlbmVyaWMgXCJTcGFuXCIgdHlwZSxcbiAqIHNvIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgYWN0dWFsbHkgaGF2ZSBhIGBTREtUcmFjZUJhc2VTcGFuYCB3aGVyZSB3ZSBjYW4gZmV0Y2ggdGhpcyBmcm9tLlxuICogT3RoZXJ3aXNlLCB3ZSBmYWxsIGJhY2sgdG8gYFNwYW5LaW5kLklOVEVSTkFMYC5cbiAqL1xuZnVuY3Rpb24gZ2V0U3BhbktpbmQoc3Bhbikge1xuICBpZiAoc3Bhbkhhc0tpbmQoc3BhbikpIHtcbiAgICByZXR1cm4gc3Bhbi5raW5kO1xuICB9XG5cbiAgcmV0dXJuIGFwaS5TcGFuS2luZC5JTlRFUk5BTDtcbn1cblxuY29uc3QgU0VOVFJZX1RSQUNFX0hFQURFUiA9ICdzZW50cnktdHJhY2UnO1xuY29uc3QgU0VOVFJZX0JBR0dBR0VfSEVBREVSID0gJ2JhZ2dhZ2UnO1xuXG5jb25zdCBTRU5UUllfVFJBQ0VfU1RBVEVfRFNDID0gJ3NlbnRyeS5kc2MnO1xuY29uc3QgU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElORyA9ICdzZW50cnkuc2FtcGxlZF9ub3RfcmVjb3JkaW5nJztcbmNvbnN0IFNFTlRSWV9UUkFDRV9TVEFURV9VUkwgPSAnc2VudHJ5LnVybCc7XG5jb25zdCBTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFX1JBTkQgPSAnc2VudHJ5LnNhbXBsZV9yYW5kJztcbmNvbnN0IFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVfUkFURSA9ICdzZW50cnkuc2FtcGxlX3JhdGUnO1xuXG5jb25zdCBTRU5UUllfU0NPUEVTX0NPTlRFWFRfS0VZID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoJ3NlbnRyeV9zY29wZXMnKTtcblxuY29uc3QgU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoJ3NlbnRyeV9mb3JrX2lzb2xhdGlvbl9zY29wZScpO1xuXG5jb25zdCBTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVkgPSBhcGkuY3JlYXRlQ29udGV4dEtleSgnc2VudHJ5X2Zvcmtfc2V0X3Njb3BlJyk7XG5cbmNvbnN0IFNFTlRSWV9GT1JLX1NFVF9JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVkgPSBhcGkuY3JlYXRlQ29udGV4dEtleSgnc2VudHJ5X2Zvcmtfc2V0X2lzb2xhdGlvbl9zY29wZScpO1xuXG5jb25zdCBTQ09QRV9DT05URVhUX0ZJRUxEID0gJ19zY29wZUNvbnRleHQnO1xuXG4vKipcbiAqIFRyeSB0byBnZXQgdGhlIGN1cnJlbnQgc2NvcGVzIGZyb20gdGhlIGdpdmVuIE9URUwgY29udGV4dC5cbiAqIFRoaXMgcmVxdWlyZXMgYSBDb250ZXh0IE1hbmFnZXIgdGhhdCB3YXMgd3JhcHBlZCB3aXRoIGdldFdyYXBwZWRDb250ZXh0TWFuYWdlci5cbiAqL1xuZnVuY3Rpb24gZ2V0U2NvcGVzRnJvbUNvbnRleHQoY29udGV4dCkge1xuICByZXR1cm4gY29udGV4dC5nZXRWYWx1ZShTRU5UUllfU0NPUEVTX0NPTlRFWFRfS0VZKSA7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IHNjb3BlcyBvbiBhbiBPVEVMIGNvbnRleHQuXG4gKiBUaGlzIHdpbGwgcmV0dXJuIGEgZm9ya2VkIGNvbnRleHQgd2l0aCB0aGUgUHJvcGFnYXRpb24gQ29udGV4dCBzZXQuXG4gKi9cbmZ1bmN0aW9uIHNldFNjb3Blc09uQ29udGV4dChjb250ZXh0LCBzY29wZXMpIHtcbiAgcmV0dXJuIGNvbnRleHQuc2V0VmFsdWUoU0VOVFJZX1NDT1BFU19DT05URVhUX0tFWSwgc2NvcGVzKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbnRleHQgb24gdGhlIHNjb3BlIHNvIHdlIGNhbiBsYXRlciBsb29rIGl0IHVwLlxuICogV2UgbmVlZCB0aGlzIHRvIGdldCB0aGUgY29udGV4dCBmcm9tIHRoZSBzY29wZSBpbiB0aGUgYHRyYWNlYCBmdW5jdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHNldENvbnRleHRPblNjb3BlKHNjb3BlLCBjb250ZXh0KSB7XG4gIGNvcmUuYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KHNjb3BlLCBTQ09QRV9DT05URVhUX0ZJRUxELCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvbnRleHQgcmVsYXRlZCB0byBhIHNjb3BlLlxuICovXG5mdW5jdGlvbiBnZXRDb250ZXh0RnJvbVNjb3BlKHNjb3BlKSB7XG4gIHJldHVybiAoc2NvcGUgKVtTQ09QRV9DT05URVhUX0ZJRUxEXTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIG90ZWxTcGFuIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gT1RFTCBTcGFuIGlzIGFuIGh0dHAgcmVxdWVzdCB0byBzZW50cnkuXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9cbmZ1bmN0aW9uIGlzU2VudHJ5UmVxdWVzdFNwYW4oc3Bhbikge1xuICBpZiAoIXNwYW5IYXNBdHRyaWJ1dGVzKHNwYW4pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgeyBhdHRyaWJ1dGVzIH0gPSBzcGFuO1xuXG4gIC8vIGBBVFRSX1VSTF9GVUxMYCBpcyB0aGUgbmV3IGF0dHJpYnV0ZSwgYnV0IHdlIHN0aWxsIHN1cHBvcnQgdGhlIG9sZCBvbmUsIGBBVFRSX0hUVFBfVVJMYCwgZm9yIG5vdy5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IGh0dHBVcmwgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdIHx8IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX1VSTF9GVUxMXTtcblxuICBpZiAoIWh0dHBVcmwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY29yZS5pc1NlbnRyeVJlcXVlc3RVcmwoaHR0cFVybC50b1N0cmluZygpLCBjb3JlLmdldENsaWVudCgpKTtcbn1cblxuLyoqXG4gKiBPcGVuVGVsZW1ldHJ5IG9ubHkga25vd3MgYWJvdXQgU0FNUExFRCBvciBOT05FIGRlY2lzaW9uLFxuICogYnV0IGZvciB1cyBpdCBpcyBpbXBvcnRhbnQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHVuc2V0IGFuZCB1bnNhbXBsZWQuXG4gKlxuICogQm90aCBvZiB0aGVzZSBhcmUgaWRlbnRpZmllZCBhcyBgdHJhY2VGbGFncyA9PT0gVHJhY2VnRmxhZ3MuTk9ORWAsXG4gKiBidXQgd2UgYWRkaXRpb25hbGx5IGxvb2sgYXQgYSBzcGVjaWFsIHRyYWNlIHN0YXRlIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB0aGVtLlxuICovXG5mdW5jdGlvbiBnZXRTYW1wbGluZ0RlY2lzaW9uKHNwYW5Db250ZXh0KSB7XG4gIGNvbnN0IHsgdHJhY2VGbGFncywgdHJhY2VTdGF0ZSB9ID0gc3BhbkNvbnRleHQ7XG5cbiAgY29uc3Qgc2FtcGxlZE5vdFJlY29yZGluZyA9IHRyYWNlU3RhdGUgPyB0cmFjZVN0YXRlLmdldChTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFRF9OT1RfUkVDT1JESU5HKSA9PT0gJzEnIDogZmFsc2U7XG5cbiAgLy8gSWYgdHJhY2UgZmxhZyBpcyBgU0FNUExFRGAsIHdlIGludGVycHJldCB0aGlzIGFzIHNhbXBsZWRcbiAgLy8gSWYgaXQgaXMgYE5PTkVgLCBpdCBjb3VsZCBtZWFuIGVpdGhlciBpdCB3YXMgc2FtcGxlZCB0byBiZSBub3QgcmVjb3JkZXIsIG9yIHRoYXQgaXQgd2FzIG5vdCBzYW1wbGVkIGF0IGFsbFxuICAvLyBGb3IgdXMgdGhpcyBpcyBhbiBpbXBvcnRhbnQgZGlmZmVyZW5jZSwgc293IGUgbG9vayBhdCB0aGUgU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElOR1xuICAvLyB0byBpZGVudGlmeSB3aGljaCBpdCBpc1xuICBpZiAodHJhY2VGbGFncyA9PT0gYXBpLlRyYWNlRmxhZ3MuU0FNUExFRCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHNhbXBsZWROb3RSZWNvcmRpbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBGYWxsIGJhY2sgdG8gRFNDIGFzIGEgbGFzdCByZXNvcnQsIHRoYXQgbWF5IGFsc28gY29udGFpbiBgc2FtcGxlZGAuLi5cbiAgY29uc3QgZHNjU3RyaW5nID0gdHJhY2VTdGF0ZSA/IHRyYWNlU3RhdGUuZ2V0KFNFTlRSWV9UUkFDRV9TVEFURV9EU0MpIDogdW5kZWZpbmVkO1xuICBjb25zdCBkc2MgPSBkc2NTdHJpbmcgPyBjb3JlLmJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQoZHNjU3RyaW5nKSA6IHVuZGVmaW5lZDtcblxuICBpZiAoZHNjPy5zYW1wbGVkID09PSAndHJ1ZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZHNjPy5zYW1wbGVkID09PSAnZmFsc2UnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBJbmZlciB0aGUgb3AgJiBkZXNjcmlwdGlvbiBmb3IgYSBzZXQgb2YgbmFtZSwgYXR0cmlidXRlcyBhbmQga2luZCBvZiBhIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIGluZmVyU3BhbkRhdGEoc3Bhbk5hbWUsIGF0dHJpYnV0ZXMsIGtpbmQpIHtcbiAgLy8gaWYgaHR0cC5tZXRob2QgZXhpc3RzLCB0aGlzIGlzIGFuIGh0dHAgcmVxdWVzdCBzcGFuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBodHRwTWV0aG9kID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF0gfHwgYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfTUVUSE9EXTtcbiAgaWYgKGh0dHBNZXRob2QpIHtcbiAgICByZXR1cm4gZGVzY3JpcHRpb25Gb3JIdHRwTWV0aG9kKHsgYXR0cmlidXRlcywgbmFtZTogc3Bhbk5hbWUsIGtpbmQgfSwgaHR0cE1ldGhvZCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgZGJTeXN0ZW0gPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfREJfU1lTVEVNXTtcbiAgY29uc3Qgb3BJc0NhY2hlID1cbiAgICB0eXBlb2YgYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdID09PSAnc3RyaW5nJyAmJlxuICAgIGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXS5zdGFydHNXaXRoKCdjYWNoZS4nKTtcblxuICAvLyBJZiBkYi50eXBlIGV4aXN0cyB0aGVuIHRoaXMgaXMgYSBkYXRhYmFzZSBjYWxsIHNwYW5cbiAgLy8gSWYgdGhlIFJlZGlzIERCIGlzIHVzZWQgYXMgYSBjYWNoZSwgdGhlIHNwYW4gZGVzY3JpcHRpb24gc2hvdWxkIG5vdCBiZSBjaGFuZ2VkXG4gIGlmIChkYlN5c3RlbSAmJiAhb3BJc0NhY2hlKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uRm9yRGJTeXN0ZW0oeyBhdHRyaWJ1dGVzLCBuYW1lOiBzcGFuTmFtZSB9KTtcbiAgfVxuXG4gIGNvbnN0IGN1c3RvbVNvdXJjZU9yUm91dGUgPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdID09PSAnY3VzdG9tJyA/ICdjdXN0b20nIDogJ3JvdXRlJztcblxuICAvLyBJZiBycGMuc2VydmljZSBleGlzdHMgdGhlbiB0aGlzIGlzIGEgcnBjIGNhbGwgc3Bhbi5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IHJwY1NlcnZpY2UgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfUlBDX1NFUlZJQ0VdO1xuICBpZiAocnBjU2VydmljZSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5nZXRVc2VyVXBkYXRlZE5hbWVBbmRTb3VyY2Uoc3Bhbk5hbWUsIGF0dHJpYnV0ZXMsICdyb3V0ZScpLFxuICAgICAgb3A6ICdycGMnLFxuICAgIH07XG4gIH1cblxuICAvLyBJZiBtZXNzYWdpbmcuc3lzdGVtIGV4aXN0cyB0aGVuIHRoaXMgaXMgYSBtZXNzYWdpbmcgc3lzdGVtIHNwYW4uXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBtZXNzYWdpbmdTeXN0ZW0gPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfTUVTU0FHSU5HX1NZU1RFTV07XG4gIGlmIChtZXNzYWdpbmdTeXN0ZW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZ2V0VXNlclVwZGF0ZWROYW1lQW5kU291cmNlKHNwYW5OYW1lLCBhdHRyaWJ1dGVzLCBjdXN0b21Tb3VyY2VPclJvdXRlKSxcbiAgICAgIG9wOiAnbWVzc2FnZScsXG4gICAgfTtcbiAgfVxuXG4gIC8vIElmIGZhYXMudHJpZ2dlciBleGlzdHMgdGhlbiB0aGlzIGlzIGEgZnVuY3Rpb24gYXMgYSBzZXJ2aWNlIHNwYW4uXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBmYWFzVHJpZ2dlciA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19GQUFTX1RSSUdHRVJdO1xuICBpZiAoZmFhc1RyaWdnZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZ2V0VXNlclVwZGF0ZWROYW1lQW5kU291cmNlKHNwYW5OYW1lLCBhdHRyaWJ1dGVzLCBjdXN0b21Tb3VyY2VPclJvdXRlKSxcbiAgICAgIG9wOiBmYWFzVHJpZ2dlci50b1N0cmluZygpLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4geyBvcDogdW5kZWZpbmVkLCBkZXNjcmlwdGlvbjogc3Bhbk5hbWUsIHNvdXJjZTogJ2N1c3RvbScgfTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGJldHRlciBvcC9kZXNjcmlwdGlvbiBmcm9tIGFuIG90ZWwgc3Bhbi5cbiAqXG4gKiBEb2VzIG5vdCBvdmVyd3JpdGUgdGhlIHNwYW4gbmFtZSBpZiB0aGUgc291cmNlIGlzIGFscmVhZHkgc2V0IHRvIGN1c3RvbSB0byBlbnN1cmVcbiAqIHRoYXQgdXNlci11cGRhdGVkIHNwYW4gbmFtZXMgYXJlIHByZXNlcnZlZC4gSW4gdGhpcyBjYXNlLCB3ZSBvbmx5IGFkanVzdCB0aGUgb3AgYnV0XG4gKiBsZWF2ZSBzcGFuIGRlc2NyaXB0aW9uIGFuZCBzb3VyY2UgdW5jaGFuZ2VkLlxuICpcbiAqIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXRlbGVtZXRyeS9vcGVudGVsZW1ldHJ5LWNvbGxlY3Rvci1jb250cmliL2Jsb2IvNzQyMmNlMmEwNjMzN2Y2OGE1OWI1NTJiOGM1YTJhYzEyNWQ2YmFlNS9leHBvcnRlci9zZW50cnlleHBvcnRlci9zZW50cnlfZXhwb3J0ZXIuZ28jTDMwNlxuICovXG5mdW5jdGlvbiBwYXJzZVNwYW5EZXNjcmlwdGlvbihzcGFuKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBzcGFuSGFzQXR0cmlidXRlcyhzcGFuKSA/IHNwYW4uYXR0cmlidXRlcyA6IHt9O1xuICBjb25zdCBuYW1lID0gc3Bhbkhhc05hbWUoc3BhbikgPyBzcGFuLm5hbWUgOiAnPHVua25vd24+JztcbiAgY29uc3Qga2luZCA9IGdldFNwYW5LaW5kKHNwYW4pO1xuXG4gIHJldHVybiBpbmZlclNwYW5EYXRhKG5hbWUsIGF0dHJpYnV0ZXMsIGtpbmQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmlwdGlvbkZvckRiU3lzdGVtKHsgYXR0cmlidXRlcywgbmFtZSB9KSB7XG4gIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGN1c3RvbSBuYW1lLCB3ZSBkb24ndCBvdmVyd3JpdGUgaXQgYnV0IG9ubHkgc2V0IHRoZSBvcFxuICBjb25zdCB1c2VyRGVmaW5lZE5hbWUgPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FXTtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmaW5lZE5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wOiAnZGInLFxuICAgICAgZGVzY3JpcHRpb246IHVzZXJEZWZpbmVkTmFtZSxcbiAgICAgIHNvdXJjZTogKGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV0gKSB8fCAnY3VzdG9tJyxcbiAgICB9O1xuICB9XG5cbiAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIHRoZSBzb3VyY2Ugc2V0IHRvIGN1c3RvbSwgd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSBzcGFuIGRlc2NyaXB0aW9uIGJ1dCBvbmx5IHNldCB0aGUgb3BcbiAgaWYgKGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV0gPT09ICdjdXN0b20nKSB7XG4gICAgcmV0dXJuIHsgb3A6ICdkYicsIGRlc2NyaXB0aW9uOiBuYW1lLCBzb3VyY2U6ICdjdXN0b20nIH07XG4gIH1cblxuICAvLyBVc2UgREIgc3RhdGVtZW50IChFeCBcIlNFTEVDVCAqIEZST00gdGFibGVcIikgaWYgcG9zc2libGUgYXMgZGVzY3JpcHRpb24uXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBzdGF0ZW1lbnQgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfREJfU1RBVEVNRU5UXTtcblxuICBjb25zdCBkZXNjcmlwdGlvbiA9IHN0YXRlbWVudCA/IHN0YXRlbWVudC50b1N0cmluZygpIDogbmFtZTtcblxuICByZXR1cm4geyBvcDogJ2RiJywgZGVzY3JpcHRpb24sIHNvdXJjZTogJ3Rhc2snIH07XG59XG5cbi8qKiBPbmx5IGV4cG9ydGVkIGZvciB0ZXN0cy4gKi9cbmZ1bmN0aW9uIGRlc2NyaXB0aW9uRm9ySHR0cE1ldGhvZChcbiAgeyBuYW1lLCBraW5kLCBhdHRyaWJ1dGVzIH0sXG4gIGh0dHBNZXRob2QsXG4pIHtcbiAgY29uc3Qgb3BQYXJ0cyA9IFsnaHR0cCddO1xuXG4gIHN3aXRjaCAoa2luZCkge1xuICAgIGNhc2UgYXBpLlNwYW5LaW5kLkNMSUVOVDpcbiAgICAgIG9wUGFydHMucHVzaCgnY2xpZW50Jyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFwaS5TcGFuS2luZC5TRVJWRVI6XG4gICAgICBvcFBhcnRzLnB1c2goJ3NlcnZlcicpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICAvLyBTcGFucyBmb3IgSFRUUCByZXF1ZXN0cyB3ZSBoYXZlIGRldGVybWluZWQgdG8gYmUgcHJlZmV0Y2ggcmVxdWVzdHMgd2lsbCBoYXZlIGEgYC5wcmVmZXRjaGAgcG9zdGZpeCBpbiB0aGUgb3BcbiAgaWYgKGF0dHJpYnV0ZXNbJ3NlbnRyeS5odHRwLnByZWZldGNoJ10pIHtcbiAgICBvcFBhcnRzLnB1c2goJ3ByZWZldGNoJyk7XG4gIH1cblxuICBjb25zdCB7IHVybFBhdGgsIHVybCwgcXVlcnksIGZyYWdtZW50LCBoYXNSb3V0ZSB9ID0gZ2V0U2FuaXRpemVkVXJsKGF0dHJpYnV0ZXMsIGtpbmQpO1xuXG4gIGlmICghdXJsUGF0aCkge1xuICAgIHJldHVybiB7IC4uLmdldFVzZXJVcGRhdGVkTmFtZUFuZFNvdXJjZShuYW1lLCBhdHRyaWJ1dGVzKSwgb3A6IG9wUGFydHMuam9pbignLicpIH07XG4gIH1cblxuICBjb25zdCBncmFwaHFsT3BlcmF0aW9uc0F0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9HUkFQSFFMX09QRVJBVElPTl07XG5cbiAgLy8gRXguIEdFVCAvYXBpL3VzZXJzXG4gIGNvbnN0IGJhc2VEZXNjcmlwdGlvbiA9IGAke2h0dHBNZXRob2R9ICR7dXJsUGF0aH1gO1xuXG4gIC8vIFdoZW4gdGhlIGh0dHAgc3BhbiBoYXMgYSBncmFwaHFsIG9wZXJhdGlvbiwgYXBwZW5kIGl0IHRvIHRoZSBkZXNjcmlwdGlvblxuICAvLyBXZSBhZGQgdGhlc2UgaW4gdGhlIGdyYXBocWxJbnRlZ3JhdGlvblxuICBjb25zdCBpbmZlcnJlZERlc2NyaXB0aW9uID0gZ3JhcGhxbE9wZXJhdGlvbnNBdHRyaWJ1dGVcbiAgICA/IGAke2Jhc2VEZXNjcmlwdGlvbn0gKCR7Z2V0R3JhcGhxbE9wZXJhdGlvbk5hbWVzRnJvbUF0dHJpYnV0ZShncmFwaHFsT3BlcmF0aW9uc0F0dHJpYnV0ZSl9KWBcbiAgICA6IGJhc2VEZXNjcmlwdGlvbjtcblxuICAvLyBJZiBgaHR0cFBhdGhgIGlzIGEgcm9vdCBwYXRoLCB0aGVuIHdlIGNhbiBjYXRlZ29yaXplIHRoZSB0cmFuc2FjdGlvbiBzb3VyY2UgYXMgcm91dGUuXG4gIGNvbnN0IGluZmVycmVkU291cmNlID0gaGFzUm91dGUgfHwgdXJsUGF0aCA9PT0gJy8nID8gJ3JvdXRlJyA6ICd1cmwnO1xuXG4gIGNvbnN0IGRhdGEgPSB7fTtcblxuICBpZiAodXJsKSB7XG4gICAgZGF0YS51cmwgPSB1cmw7XG4gIH1cbiAgaWYgKHF1ZXJ5KSB7XG4gICAgZGF0YVsnaHR0cC5xdWVyeSddID0gcXVlcnk7XG4gIH1cbiAgaWYgKGZyYWdtZW50KSB7XG4gICAgZGF0YVsnaHR0cC5mcmFnbWVudCddID0gZnJhZ21lbnQ7XG4gIH1cblxuICAvLyBJZiB0aGUgc3BhbiBraW5kIGlzIG5laXRoZXIgY2xpZW50IG5vciBzZXJ2ZXIsIHdlIHVzZSB0aGUgb3JpZ2luYWwgbmFtZVxuICAvLyB0aGlzIGluZmVycyB0aGF0IHNvbWVib2R5IG1hbnVhbGx5IHN0YXJ0ZWQgdGhpcyBzcGFuLCBpbiB3aGljaCBjYXNlIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIHRoZSBuYW1lXG4gIGNvbnN0IGlzQ2xpZW50T3JTZXJ2ZXJLaW5kID0ga2luZCA9PT0gYXBpLlNwYW5LaW5kLkNMSUVOVCB8fCBraW5kID09PSBhcGkuU3BhbktpbmQuU0VSVkVSO1xuXG4gIC8vIElmIHRoZSBzcGFuIGlzIGFuIGF1dG8tc3BhbiAoPWl0IGNvbWVzIGZyb20gb25lIG9mIG91ciBpbnN0cnVtZW50YXRpb25zKSxcbiAgLy8gd2UgYWx3YXlzIHdhbnQgdG8gaW5mZXIgdGhlIG5hbWVcbiAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzb21lIG9mIHRoZSBhdXRvLWluc3RydW1lbnRhdGlvbiB3ZSB1c2UgdXNlcyBraW5kPUlOVEVSTkFMXG4gIGNvbnN0IG9yaWdpbiA9IGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl0gfHwgJ21hbnVhbCc7XG4gIGNvbnN0IGlzTWFudWFsU3BhbiA9ICFgJHtvcmlnaW59YC5zdGFydHNXaXRoKCdhdXRvJyk7XG5cbiAgLy8gSWYgdXNlcnMgKG9yIGluIHZlcnkgcmFyZSBvY2Nhc2lvbnMgd2UpIHNldCB0aGUgc291cmNlIHRvIGN1c3RvbSwgd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSBuYW1lXG4gIGNvbnN0IGFscmVhZHlIYXNDdXN0b21Tb3VyY2UgPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdID09PSAnY3VzdG9tJztcbiAgY29uc3QgY3VzdG9tU3Bhbk5hbWUgPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FXTtcblxuICBjb25zdCB1c2VJbmZlcnJlZERlc2NyaXB0aW9uID1cbiAgICAhYWxyZWFkeUhhc0N1c3RvbVNvdXJjZSAmJiBjdXN0b21TcGFuTmFtZSA9PSBudWxsICYmIChpc0NsaWVudE9yU2VydmVyS2luZCB8fCAhaXNNYW51YWxTcGFuKTtcblxuICBjb25zdCB7IGRlc2NyaXB0aW9uLCBzb3VyY2UgfSA9IHVzZUluZmVycmVkRGVzY3JpcHRpb25cbiAgICA/IHsgZGVzY3JpcHRpb246IGluZmVycmVkRGVzY3JpcHRpb24sIHNvdXJjZTogaW5mZXJyZWRTb3VyY2UgfVxuICAgIDogZ2V0VXNlclVwZGF0ZWROYW1lQW5kU291cmNlKG5hbWUsIGF0dHJpYnV0ZXMpO1xuXG4gIHJldHVybiB7XG4gICAgb3A6IG9wUGFydHMuam9pbignLicpLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIHNvdXJjZSxcbiAgICBkYXRhLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRHcmFwaHFsT3BlcmF0aW9uTmFtZXNGcm9tQXR0cmlidXRlKGF0dHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cikpIHtcbiAgICBjb25zdCBzb3J0ZWQgPSBhdHRyLnNsaWNlKCkuc29ydCgpO1xuXG4gICAgLy8gVXAgdG8gNSBpdGVtcywgd2UganVzdCBhZGQgYWxsIG9mIHRoZW1cbiAgICBpZiAoc29ydGVkLmxlbmd0aCA8PSA1KSB7XG4gICAgICByZXR1cm4gc29ydGVkLmpvaW4oJywgJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVsc2UsIHdlIGFkZCB0aGUgZmlyc3QgNSBhbmQgdGhlIGRpZmYgb2Ygb3RoZXIgb3BlcmF0aW9uc1xuICAgICAgcmV0dXJuIGAke3NvcnRlZC5zbGljZSgwLCA1KS5qb2luKCcsICcpfSwgKyR7c29ydGVkLmxlbmd0aCAtIDV9YDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYCR7YXR0cn1gO1xufVxuXG4vKiogRXhwb3J0ZWQgZm9yIHRlc3RzIG9ubHkgKi9cbmZ1bmN0aW9uIGdldFNhbml0aXplZFVybChcbiAgYXR0cmlidXRlcyxcbiAga2luZCxcbilcblxuIHtcbiAgLy8gVGhpcyBpcyB0aGUgcmVsYXRpdmUgcGF0aCBvZiB0aGUgVVJMLCBlLmcuIC9zdWJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IGh0dHBUYXJnZXQgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9UQVJHRVRdO1xuICAvLyBUaGlzIGlzIHRoZSBmdWxsIFVSTCwgaW5jbHVkaW5nIGhvc3QgJiBxdWVyeSBwYXJhbXMgZXRjLiwgZS5nLiBodHRwczovL2V4YW1wbGUuY29tL3N1Yj9mb289YmFyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBodHRwVXJsID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVVJMXSB8fCBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9VUkxfRlVMTF07XG4gIC8vIFRoaXMgaXMgdGhlIG5vcm1hbGl6ZWQgcm91dGUgbmFtZSAtIG1heSBub3QgYWx3YXlzIGJlIGF2YWlsYWJsZSFcbiAgY29uc3QgaHR0cFJvdXRlID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLkFUVFJfSFRUUF9ST1VURV07XG5cbiAgY29uc3QgcGFyc2VkVXJsID0gdHlwZW9mIGh0dHBVcmwgPT09ICdzdHJpbmcnID8gY29yZS5wYXJzZVVybChodHRwVXJsKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgdXJsID0gcGFyc2VkVXJsID8gY29yZS5nZXRTYW5pdGl6ZWRVcmxTdHJpbmcocGFyc2VkVXJsKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgcXVlcnkgPSBwYXJzZWRVcmw/LnNlYXJjaCB8fCB1bmRlZmluZWQ7XG4gIGNvbnN0IGZyYWdtZW50ID0gcGFyc2VkVXJsPy5oYXNoIHx8IHVuZGVmaW5lZDtcblxuICBpZiAodHlwZW9mIGh0dHBSb3V0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4geyB1cmxQYXRoOiBodHRwUm91dGUsIHVybCwgcXVlcnksIGZyYWdtZW50LCBoYXNSb3V0ZTogdHJ1ZSB9O1xuICB9XG5cbiAgaWYgKGtpbmQgPT09IGFwaS5TcGFuS2luZC5TRVJWRVIgJiYgdHlwZW9mIGh0dHBUYXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHsgdXJsUGF0aDogY29yZS5zdHJpcFVybFF1ZXJ5QW5kRnJhZ21lbnQoaHR0cFRhcmdldCksIHVybCwgcXVlcnksIGZyYWdtZW50LCBoYXNSb3V0ZTogZmFsc2UgfTtcbiAgfVxuXG4gIGlmIChwYXJzZWRVcmwpIHtcbiAgICByZXR1cm4geyB1cmxQYXRoOiB1cmwsIHVybCwgcXVlcnksIGZyYWdtZW50LCBoYXNSb3V0ZTogZmFsc2UgfTtcbiAgfVxuXG4gIC8vIGZhbGwgYmFjayB0byB0YXJnZXQgZXZlbiBmb3IgY2xpZW50IHNwYW5zLCBpZiBubyBVUkwgaXMgcHJlc2VudFxuICBpZiAodHlwZW9mIGh0dHBUYXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHsgdXJsUGF0aDogY29yZS5zdHJpcFVybFF1ZXJ5QW5kRnJhZ21lbnQoaHR0cFRhcmdldCksIHVybCwgcXVlcnksIGZyYWdtZW50LCBoYXNSb3V0ZTogZmFsc2UgfTtcbiAgfVxuXG4gIHJldHVybiB7IHVybFBhdGg6IHVuZGVmaW5lZCwgdXJsLCBxdWVyeSwgZnJhZ21lbnQsIGhhc1JvdXRlOiBmYWxzZSB9O1xufVxuXG4vKipcbiAqIEJlY2F1c2UgT3RlbCBpbnN0cnVtZW50YXRpb24gc29tZXRpbWVzIG11dGF0ZXMgc3BhbiBuYW1lcyB2aWEgYHNwYW4udXBkYXRlTmFtZWAsIHRoZSBvbmx5IHdheVxuICogdG8gZW5zdXJlIHRoYXQgYSB1c2VyLXNldCBzcGFuIG5hbWUgaXMgcHJlc2VydmVkIGlzIHRvIHN0b3JlIGl0IGFzIGEgdG1wIGF0dHJpYnV0ZSBvbiB0aGUgc3Bhbi5cbiAqIFdlIGRlbGV0ZSB0aGlzIGF0dHJpYnV0ZSBvbmNlIHdlJ3JlIGRvbmUgd2l0aCBpdCB3aGVuIHByZXBhcmluZyB0aGUgZXZlbnQgZW52ZWxvcGUuXG4gKlxuICogVGhpcyB0ZW1wIGF0dHJpYnV0ZSBhbHdheXMgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoZSBvcmlnaW5hbCBuYW1lLlxuICpcbiAqIFdlIGFsc28gbmVlZCB0byB0YWtlIGNhcmUgb2Ygc2V0dGluZyB0aGUgY29ycmVjdCBzb3VyY2UuIFVzZXJzIGNhbiBhbHdheXMgdXBkYXRlIHRoZSBzb3VyY2VcbiAqIGFmdGVyIHVwZGF0aW5nIHRoZSBuYW1lLCBzbyB3ZSBuZWVkIHRvIHJlc3BlY3QgdGhhdC5cbiAqXG4gKiBAaW50ZXJuYWwgZXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZ1xuICovXG5mdW5jdGlvbiBnZXRVc2VyVXBkYXRlZE5hbWVBbmRTb3VyY2UoXG4gIG9yaWdpbmFsTmFtZSxcbiAgYXR0cmlidXRlcyxcbiAgZmFsbGJhY2tTb3VyY2UgPSAnY3VzdG9tJyxcbilcblxuIHtcbiAgY29uc3Qgc291cmNlID0gKGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV0gKSB8fCBmYWxsYmFja1NvdXJjZTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FXTtcblxuICBpZiAoZGVzY3JpcHRpb24gJiYgdHlwZW9mIGRlc2NyaXB0aW9uID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7XG4gICAgICBkZXNjcmlwdGlvbixcbiAgICAgIHNvdXJjZSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHsgZGVzY3JpcHRpb246IG9yaWdpbmFsTmFtZSwgc291cmNlIH07XG59XG5cbi8qKlxuICogU2V0dXAgYSBEU0MgaGFuZGxlciBvbiB0aGUgcGFzc2VkIGNsaWVudCxcbiAqIGVuc3VyaW5nIHRoYXQgdGhlIHRyYW5zYWN0aW9uIG5hbWUgaXMgaW5mZXJyZWQgZnJvbSB0aGUgc3BhbiBjb3JyZWN0bHkuXG4gKi9cbmZ1bmN0aW9uIGVuaGFuY2VEc2NXaXRoT3BlblRlbGVtZXRyeVJvb3RTcGFuTmFtZShjbGllbnQpIHtcbiAgY2xpZW50Lm9uKCdjcmVhdGVEc2MnLCAoZHNjLCByb290U3BhbikgPT4ge1xuICAgIGlmICghcm9vdFNwYW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZSB3YW50IHRvIG92ZXJ3cml0ZSB0aGUgdHJhbnNhY3Rpb24gb24gdGhlIERTQyB0aGF0IGlzIGNyZWF0ZWQgYnkgZGVmYXVsdCBpbiBjb3JlXG4gICAgLy8gVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IHdlIHdhbnQgdG8gaW5mZXIgdGhlIHNwYW4gbmFtZSwgbm90IHVzZSB0aGUgaW5pdGlhbCBvbmVcbiAgICAvLyBPdGhlcndpc2UsIHdlJ2xsIGdldCBuYW1lcyBsaWtlIFwiR0VUXCIgaW5zdGVhZCBvZiBlLmcuIFwiR0VUIC9mb29cIlxuICAgIC8vIGBwYXJzZVNwYW5EZXNjcmlwdGlvbmAgdGFrZXMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHNwYW4gaW50byBhY2NvdW50IGZvciB0aGUgbmFtZVxuICAgIC8vIFRoaXMgbXV0YXRlcyB0aGUgcGFzc2VkLWluIERTQ1xuXG4gICAgY29uc3QganNvblNwYW4gPSBjb3JlLnNwYW5Ub0pTT04ocm9vdFNwYW4pO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBqc29uU3Bhbi5kYXRhO1xuICAgIGNvbnN0IHNvdXJjZSA9IGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV07XG5cbiAgICBjb25zdCB7IGRlc2NyaXB0aW9uIH0gPSBzcGFuSGFzTmFtZShyb290U3BhbikgPyBwYXJzZVNwYW5EZXNjcmlwdGlvbihyb290U3BhbikgOiB7IGRlc2NyaXB0aW9uOiB1bmRlZmluZWQgfTtcbiAgICBpZiAoc291cmNlICE9PSAndXJsJyAmJiBkZXNjcmlwdGlvbikge1xuICAgICAgZHNjLnRyYW5zYWN0aW9uID0gZGVzY3JpcHRpb247XG4gICAgfVxuXG4gICAgLy8gQWxzbyBlbnN1cmUgc2FtcGxpbmcgZGVjaXNpb24gaXMgY29ycmVjdGx5IGluZmVycmVkXG4gICAgLy8gSW4gY29yZSwgd2UgdXNlIGBzcGFuSXNTYW1wbGVkYCwgd2hpY2gganVzdCBsb29rcyBhdCB0aGUgdHJhY2UgZmxhZ3NcbiAgICAvLyBidXQgaW4gT1RFTCwgd2UgdXNlIGEgc2xpZ2h0bHkgbW9yZSBjb21wbGV4IGxvZ2ljIHRvIGJlIGFibGUgdG8gZGlmZmVybnRpYXRlIGJldHdlZW4gdW5zYW1wbGVkIGFuZCBkZWZlcnJlZCBzYW1wbGluZ1xuICAgIGlmIChjb3JlLmhhc1NwYW5zRW5hYmxlZCgpKSB7XG4gICAgICBjb25zdCBzYW1wbGVkID0gZ2V0U2FtcGxpbmdEZWNpc2lvbihyb290U3Bhbi5zcGFuQ29udGV4dCgpKTtcbiAgICAgIGRzYy5zYW1wbGVkID0gc2FtcGxlZCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBTdHJpbmcoc2FtcGxlZCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZVNwYW4oKSB7XG4gIHJldHVybiBhcGkudHJhY2UuZ2V0QWN0aXZlU3BhbigpO1xufVxuXG4vKipcbiAqIFRoaXMgc2VydmVzIGFzIGEgYnVpbGQgdGltZSBmbGFnIHRoYXQgd2lsbCBiZSB0cnVlIGJ5IGRlZmF1bHQsIGJ1dCBmYWxzZSBpbiBub24tZGVidWcgYnVpbGRzIG9yIGlmIHVzZXJzIHJlcGxhY2UgYF9fU0VOVFJZX0RFQlVHX19gIGluIHRoZWlyIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEFUVEVOVElPTjogVGhpcyBjb25zdGFudCBtdXN0IG5ldmVyIGNyb3NzIHBhY2thZ2UgYm91bmRhcmllcyAoaS5lLiBiZSBleHBvcnRlZCkgdG8gZ3VhcmFudGVlIHRoYXQgaXQgY2FuIGJlIHVzZWQgZm9yIHRyZWUgc2hha2luZy5cbiAqL1xuY29uc3QgREVCVUdfQlVJTEQgPSAodHlwZW9mIF9fU0VOVFJZX0RFQlVHX18gPT09ICd1bmRlZmluZWQnIHx8IF9fU0VOVFJZX0RFQlVHX18pO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgVHJhY2VTdGF0ZSBmb3IgdGhlIGdpdmVuIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIG1ha2VUcmFjZVN0YXRlKHtcbiAgZHNjLFxuICBzYW1wbGVkLFxufVxuXG4pIHtcbiAgLy8gV2Ugc3RvcmUgdGhlIERTQyBhcyBPVEVMIHRyYWNlIHN0YXRlIG9uIHRoZSBzcGFuIGNvbnRleHRcbiAgY29uc3QgZHNjU3RyaW5nID0gZHNjID8gY29yZS5keW5hbWljU2FtcGxpbmdDb250ZXh0VG9TZW50cnlCYWdnYWdlSGVhZGVyKGRzYykgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgdHJhY2VTdGF0ZUJhc2UgPSBuZXcgY29yZSQxLlRyYWNlU3RhdGUoKTtcblxuICBjb25zdCB0cmFjZVN0YXRlV2l0aERzYyA9IGRzY1N0cmluZyA/IHRyYWNlU3RhdGVCYXNlLnNldChTRU5UUllfVFJBQ0VfU1RBVEVfRFNDLCBkc2NTdHJpbmcpIDogdHJhY2VTdGF0ZUJhc2U7XG5cbiAgLy8gV2UgYWxzbyBzcGVjaWZpY2FsbHkgd2FudCB0byBzdG9yZSBpZiB0aGlzIGlzIHNhbXBsZWQgdG8gYmUgbm90IHJlY29yZGluZyxcbiAgLy8gb3IgdW5zYW1wbGVkICg9Y291bGQgYmUgZWl0aGVyIHNhbXBsZWQgb3Igbm90KVxuICByZXR1cm4gc2FtcGxlZCA9PT0gZmFsc2UgPyB0cmFjZVN0YXRlV2l0aERzYy5zZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElORywgJzEnKSA6IHRyYWNlU3RhdGVXaXRoRHNjO1xufVxuXG5jb25zdCBzZXR1cEVsZW1lbnRzID0gbmV3IFNldCgpO1xuXG4vKiogR2V0IGFsbCB0aGUgT3BlblRlbGVtZXRyeSBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiBzZXQgdXAuICovXG5mdW5jdGlvbiBvcGVuVGVsZW1ldHJ5U2V0dXBDaGVjaygpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0dXBFbGVtZW50cyk7XG59XG5cbi8qKiBNYXJrIGFuIE9wZW5UZWxlbWV0cnkgZWxlbWVudCBhcyBzZXR1cC4gKi9cbmZ1bmN0aW9uIHNldElzU2V0dXAoZWxlbWVudCkge1xuICBzZXR1cEVsZW1lbnRzLmFkZChlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBJbmplY3RzIGFuZCBleHRyYWN0cyBgc2VudHJ5LXRyYWNlYCBhbmQgYGJhZ2dhZ2VgIGhlYWRlcnMgZnJvbSBjYXJyaWVycy5cbiAqL1xuY2xhc3MgU2VudHJ5UHJvcGFnYXRvciBleHRlbmRzIGNvcmUkMS5XM0NCYWdnYWdlUHJvcGFnYXRvciB7XG4gIC8qKiBBIG1hcCBvZiBVUkxzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gY2hlY2tlZCBmb3IgaWYgdGhleSBtYXRjaCB0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cy4gKi9cblxuICAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBzZXRJc1NldHVwKCdTZW50cnlQcm9wYWdhdG9yJyk7XG5cbiAgICAvLyBXZSdyZSBjYWNoaW5nIHJlc3VsdHMgc28gd2UgZG9uJ3QgaGF2ZSB0byByZWNvbXB1dGUgcmVnZXhwIGV2ZXJ5IHRpbWUgd2UgY3JlYXRlIGEgcmVxdWVzdC5cbiAgICB0aGlzLl91cmxNYXRjaGVzVGFyZ2V0c01hcCA9IG5ldyBjb3JlLkxSVU1hcCgxMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgaW5qZWN0KGNvbnRleHQsIGNhcnJpZXIsIHNldHRlcikge1xuICAgIGlmIChjb3JlJDEuaXNUcmFjaW5nU3VwcHJlc3NlZChjb250ZXh0KSkge1xuICAgICAgREVCVUdfQlVJTEQgJiYgY29yZS5kZWJ1Zy5sb2coJ1tUcmFjaW5nXSBOb3QgaW5qZWN0aW5nIHRyYWNlIGRhdGEgZm9yIHVybCBiZWNhdXNlIHRyYWNpbmcgaXMgc3VwcHJlc3NlZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVTcGFuID0gYXBpLnRyYWNlLmdldFNwYW4oY29udGV4dCk7XG4gICAgY29uc3QgdXJsID0gYWN0aXZlU3BhbiAmJiBnZXRDdXJyZW50VVJMKGFjdGl2ZVNwYW4pO1xuXG4gICAgY29uc3QgdHJhY2VQcm9wYWdhdGlvblRhcmdldHMgPSBjb3JlLmdldENsaWVudCgpPy5nZXRPcHRpb25zKCk/LnRyYWNlUHJvcGFnYXRpb25UYXJnZXRzO1xuICAgIGlmICghc2hvdWxkUHJvcGFnYXRlVHJhY2VGb3JVcmwodXJsLCB0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cywgdGhpcy5fdXJsTWF0Y2hlc1RhcmdldHNNYXApKSB7XG4gICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICBjb3JlLmRlYnVnLmxvZygnW1RyYWNpbmddIE5vdCBpbmplY3RpbmcgdHJhY2UgZGF0YSBmb3IgdXJsIGJlY2F1c2UgaXQgZG9lcyBub3QgbWF0Y2ggdHJhY2VQcm9wYWdhdGlvblRhcmdldHM6JywgdXJsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBleGlzdGluZ0JhZ2dhZ2VIZWFkZXIgPSBnZXRFeGlzdGluZ0JhZ2dhZ2UoY2Fycmllcik7XG4gICAgbGV0IGJhZ2dhZ2UgPSBhcGkucHJvcGFnYXRpb24uZ2V0QmFnZ2FnZShjb250ZXh0KSB8fCBhcGkucHJvcGFnYXRpb24uY3JlYXRlQmFnZ2FnZSh7fSk7XG5cbiAgICBjb25zdCB7IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsIHRyYWNlSWQsIHNwYW5JZCwgc2FtcGxlZCB9ID0gZ2V0SW5qZWN0aW9uRGF0YShjb250ZXh0KTtcblxuICAgIGlmIChleGlzdGluZ0JhZ2dhZ2VIZWFkZXIpIHtcbiAgICAgIGNvbnN0IGJhZ2dhZ2VFbnRyaWVzID0gY29yZS5wYXJzZUJhZ2dhZ2VIZWFkZXIoZXhpc3RpbmdCYWdnYWdlSGVhZGVyKTtcblxuICAgICAgaWYgKGJhZ2dhZ2VFbnRyaWVzKSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGJhZ2dhZ2VFbnRyaWVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICBiYWdnYWdlID0gYmFnZ2FnZS5zZXRFbnRyeShrZXksIHsgdmFsdWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkeW5hbWljU2FtcGxpbmdDb250ZXh0KSB7XG4gICAgICBiYWdnYWdlID0gT2JqZWN0LmVudHJpZXMoZHluYW1pY1NhbXBsaW5nQ29udGV4dCkucmVkdWNlKChiLCBbZHNjS2V5LCBkc2NWYWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKGRzY1ZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGIuc2V0RW50cnkoYCR7Y29yZS5TRU5UUllfQkFHR0FHRV9LRVlfUFJFRklYfSR7ZHNjS2V5fWAsIHsgdmFsdWU6IGRzY1ZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSwgYmFnZ2FnZSk7XG4gICAgfVxuXG4gICAgLy8gV2UgYWxzbyB3YW50IHRvIGF2b2lkIHNldHRpbmcgdGhlIGRlZmF1bHQgT1RFTCB0cmFjZSBJRCwgaWYgd2UgZ2V0IHRoYXQgZm9yIHdoYXRldmVyIHJlYXNvblxuICAgIGlmICh0cmFjZUlkICYmIHRyYWNlSWQgIT09IGFwaS5JTlZBTElEX1RSQUNFSUQpIHtcbiAgICAgIHNldHRlci5zZXQoY2FycmllciwgU0VOVFJZX1RSQUNFX0hFQURFUiwgY29yZS5nZW5lcmF0ZVNlbnRyeVRyYWNlSGVhZGVyKHRyYWNlSWQsIHNwYW5JZCwgc2FtcGxlZCkpO1xuICAgIH1cblxuICAgIHN1cGVyLmluamVjdChhcGkucHJvcGFnYXRpb24uc2V0QmFnZ2FnZShjb250ZXh0LCBiYWdnYWdlKSwgY2Fycmllciwgc2V0dGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGV4dHJhY3QoY29udGV4dCwgY2FycmllciwgZ2V0dGVyKSB7XG4gICAgY29uc3QgbWF5YmVTZW50cnlUcmFjZUhlYWRlciA9IGdldHRlci5nZXQoY2FycmllciwgU0VOVFJZX1RSQUNFX0hFQURFUik7XG4gICAgY29uc3QgYmFnZ2FnZSA9IGdldHRlci5nZXQoY2FycmllciwgU0VOVFJZX0JBR0dBR0VfSEVBREVSKTtcblxuICAgIGNvbnN0IHNlbnRyeVRyYWNlID0gbWF5YmVTZW50cnlUcmFjZUhlYWRlclxuICAgICAgPyBBcnJheS5pc0FycmF5KG1heWJlU2VudHJ5VHJhY2VIZWFkZXIpXG4gICAgICAgID8gbWF5YmVTZW50cnlUcmFjZUhlYWRlclswXVxuICAgICAgICA6IG1heWJlU2VudHJ5VHJhY2VIZWFkZXJcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gQWRkIHJlbW90ZSBwYXJlbnQgc3BhbiBjb250ZXh0XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gaW5jb21pbmcgdHJhY2UsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGNvbnRleHQgYXMtaXNcbiAgICByZXR1cm4gZW5zdXJlU2NvcGVzT25Db250ZXh0KGdldENvbnRleHRXaXRoUmVtb3RlQWN0aXZlU3Bhbihjb250ZXh0LCB7IHNlbnRyeVRyYWNlLCBiYWdnYWdlIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGZpZWxkcygpIHtcbiAgICByZXR1cm4gW1NFTlRSWV9UUkFDRV9IRUFERVIsIFNFTlRSWV9CQUdHQUdFX0hFQURFUl07XG4gIH1cbn1cblxuY29uc3QgTk9UX1BST1BBR0FURURfTUVTU0FHRSA9XG4gICdbVHJhY2luZ10gTm90IGluamVjdGluZyB0cmFjZSBkYXRhIGZvciB1cmwgYmVjYXVzZSBpdCBkb2VzIG5vdCBtYXRjaCB0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0czonO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gVVJMIHNob3VsZCBiZSBwcm9wYWdhdGVkIHRvIG9yIG5vdC5cbiAqIElmIG5vIHVybCBpcyBkZWZpbmVkLCBvciBubyB0cmFjZSBwcm9wYWdhdGlvbiB0YXJnZXRzIGFyZSBkZWZpbmVkLCB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiBgdHJ1ZWAuXG4gKiBZb3UgY2FuIGFsc28gb3B0aW9uYWxseSBwcm92aWRlIGEgZGVjaXNpb24gbWFwLCB0byBjYWNoZSBkZWNpc2lvbnMgYW5kIGF2b2lkIHJlcGVhdGVkIHJlZ2V4IGxvb2t1cHMuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFByb3BhZ2F0ZVRyYWNlRm9yVXJsKFxuICB1cmwsXG4gIHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzLFxuICBkZWNpc2lvbk1hcCxcbikge1xuICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycgfHwgIXRyYWNlUHJvcGFnYXRpb25UYXJnZXRzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBjYWNoZWREZWNpc2lvbiA9IGRlY2lzaW9uTWFwPy5nZXQodXJsKTtcbiAgaWYgKGNhY2hlZERlY2lzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBERUJVR19CVUlMRCAmJiAhY2FjaGVkRGVjaXNpb24gJiYgY29yZS5kZWJ1Zy5sb2coTk9UX1BST1BBR0FURURfTUVTU0FHRSwgdXJsKTtcbiAgICByZXR1cm4gY2FjaGVkRGVjaXNpb247XG4gIH1cblxuICBjb25zdCBkZWNpc2lvbiA9IGNvcmUuc3RyaW5nTWF0Y2hlc1NvbWVQYXR0ZXJuKHVybCwgdHJhY2VQcm9wYWdhdGlvblRhcmdldHMpO1xuICBkZWNpc2lvbk1hcD8uc2V0KHVybCwgZGVjaXNpb24pO1xuXG4gIERFQlVHX0JVSUxEICYmICFkZWNpc2lvbiAmJiBjb3JlLmRlYnVnLmxvZyhOT1RfUFJPUEFHQVRFRF9NRVNTQUdFLCB1cmwpO1xuICByZXR1cm4gZGVjaXNpb247XG59XG5cbi8qKlxuICogR2V0IHByb3BhZ2F0aW9uIGluamVjdGlvbiBkYXRhIGZvciB0aGUgZ2l2ZW4gY29udGV4dC5cbiAqIFRoZSBhZGRpdGlvbmFsIG9wdGlvbnMgY2FuIGJlIHBhc3NlZCB0byBvdmVycmlkZSB0aGUgc2NvcGUgYW5kIGNsaWVudCB0aGF0IGlzIG90aGVyd2lzZSBkZXJpdmVkIGZyb20gdGhlIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGdldEluamVjdGlvbkRhdGEoXG4gIGNvbnRleHQsXG4gIG9wdGlvbnMgPSB7fSxcbilcblxuIHtcbiAgY29uc3Qgc3BhbiA9IGFwaS50cmFjZS5nZXRTcGFuKGNvbnRleHQpO1xuXG4gIC8vIElmIHdlIGhhdmUgYSByZW1vdGUgc3BhbiwgdGhlIHNwYW5JZCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyB0aGUgcGFyZW50U3BhbklkLCBub3Qgc3BhbklkIGl0c2VsZlxuICAvLyBJbnN0ZWFkLCB3ZSB1c2UgYSB2aXJ0dWFsIChnZW5lcmF0ZWQpIHNwYW5JZCBmb3IgcHJvcGFnYXRpb25cbiAgaWYgKHNwYW4/LnNwYW5Db250ZXh0KCkuaXNSZW1vdGUpIHtcbiAgICBjb25zdCBzcGFuQ29udGV4dCA9IHNwYW4uc3BhbkNvbnRleHQoKTtcbiAgICBjb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gY29yZS5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4oc3Bhbik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dCxcbiAgICAgIHRyYWNlSWQ6IHNwYW5Db250ZXh0LnRyYWNlSWQsXG4gICAgICBzcGFuSWQ6IHVuZGVmaW5lZCxcbiAgICAgIHNhbXBsZWQ6IGdldFNhbXBsaW5nRGVjaXNpb24oc3BhbkNvbnRleHQpLCAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIGNoYW5nZSBzb21ldGhpbmcgaGVyZT9cbiAgICB9O1xuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIGxvY2FsIHNwYW4sIHdlIGp1c3QgdXNlIHRoaXNcbiAgaWYgKHNwYW4pIHtcbiAgICBjb25zdCBzcGFuQ29udGV4dCA9IHNwYW4uc3BhbkNvbnRleHQoKTtcbiAgICBjb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gY29yZS5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4oc3Bhbik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dCxcbiAgICAgIHRyYWNlSWQ6IHNwYW5Db250ZXh0LnRyYWNlSWQsXG4gICAgICBzcGFuSWQ6IHNwYW5Db250ZXh0LnNwYW5JZCxcbiAgICAgIHNhbXBsZWQ6IGdldFNhbXBsaW5nRGVjaXNpb24oc3BhbkNvbnRleHQpLCAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIGNoYW5nZSBzb21ldGhpbmcgaGVyZT9cbiAgICB9O1xuICB9XG5cbiAgLy8gRWxzZSB3ZSB0cnkgdG8gdXNlIHRoZSBwcm9wYWdhdGlvbiBjb250ZXh0IGZyb20gdGhlIHNjb3BlXG4gIC8vIFRoZSBvbmx5IHNjZW5hcmlvIHdoZXJlIHRoaXMgc2hvdWxkIGhhcHBlbiBpcyB3aGVuIHdlIG5laXRoZXIgaGF2ZSBhIHNwYW4sIG5vciBhbiBpbmNvbWluZyB0cmFjZVxuICBjb25zdCBzY29wZSA9IG9wdGlvbnMuc2NvcGUgfHwgZ2V0U2NvcGVzRnJvbUNvbnRleHQoY29udGV4dCk/LnNjb3BlIHx8IGNvcmUuZ2V0Q3VycmVudFNjb3BlKCk7XG4gIGNvbnN0IGNsaWVudCA9IG9wdGlvbnMuY2xpZW50IHx8IGNvcmUuZ2V0Q2xpZW50KCk7XG5cbiAgY29uc3QgcHJvcGFnYXRpb25Db250ZXh0ID0gc2NvcGUuZ2V0UHJvcGFnYXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSBjbGllbnQgPyBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU2NvcGUoY2xpZW50LCBzY29wZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiB7XG4gICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dCxcbiAgICB0cmFjZUlkOiBwcm9wYWdhdGlvbkNvbnRleHQudHJhY2VJZCxcbiAgICBzcGFuSWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5wcm9wYWdhdGlvblNwYW5JZCxcbiAgICBzYW1wbGVkOiBwcm9wYWdhdGlvbkNvbnRleHQuc2FtcGxlZCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dFdpdGhSZW1vdGVBY3RpdmVTcGFuKFxuICBjdHgsXG4gIHsgc2VudHJ5VHJhY2UsIGJhZ2dhZ2UgfSxcbikge1xuICBjb25zdCBwcm9wYWdhdGlvbkNvbnRleHQgPSBjb3JlLnByb3BhZ2F0aW9uQ29udGV4dEZyb21IZWFkZXJzKHNlbnRyeVRyYWNlLCBiYWdnYWdlKTtcblxuICBjb25zdCB7IHRyYWNlSWQsIHBhcmVudFNwYW5JZCwgc2FtcGxlZCwgZHNjIH0gPSBwcm9wYWdhdGlvbkNvbnRleHQ7XG5cbiAgY29uc3QgY2xpZW50ID0gY29yZS5nZXRDbGllbnQoKTtcbiAgY29uc3QgaW5jb21pbmdEc2MgPSBjb3JlLmJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQoYmFnZ2FnZSk7XG5cbiAgLy8gV2Ugb25seSB3YW50IHRvIHNldCB0aGUgdmlydHVhbCBzcGFuIGlmIHdlIGFyZSBjb250aW51aW5nIGEgY29uY3JldGUgdHJhY2VcbiAgLy8gT3RoZXJ3aXNlLCB3ZSBpZ25vcmUgdGhlIGluY29taW5nIHRyYWNlIGhlcmUsIGUuZy4gaWYgd2UgaGF2ZSBubyB0cmFjZSBoZWFkZXJzXG4gIGlmICghcGFyZW50U3BhbklkIHx8IChjbGllbnQgJiYgIWNvcmUuc2hvdWxkQ29udGludWVUcmFjZShjbGllbnQsIGluY29taW5nRHNjPy5vcmdfaWQpKSkge1xuICAgIHJldHVybiBjdHg7XG4gIH1cblxuICBjb25zdCBzcGFuQ29udGV4dCA9IGdlbmVyYXRlUmVtb3RlU3BhbkNvbnRleHQoe1xuICAgIHRyYWNlSWQsXG4gICAgc3BhbklkOiBwYXJlbnRTcGFuSWQsXG4gICAgc2FtcGxlZCxcbiAgICBkc2MsXG4gIH0pO1xuXG4gIHJldHVybiBhcGkudHJhY2Uuc2V0U3BhbkNvbnRleHQoY3R4LCBzcGFuQ29udGV4dCk7XG59XG5cbi8qKlxuICogVGFrZXMgdHJhY2Ugc3RyaW5ncyBhbmQgcHJvcGFnYXRlcyB0aGVtIGFzIGEgcmVtb3RlIGFjdGl2ZSBzcGFuLlxuICogVGhpcyBzaG91bGQgYmUgdXNlZCBpbiBhZGRpdGlvbiB0byBgY29udGludWVUcmFjZWAgaW4gT1RFTC1wb3dlcmVkIGVudmlyb25tZW50cy5cbiAqL1xuZnVuY3Rpb24gY29udGludWVUcmFjZUFzUmVtb3RlU3BhbihcbiAgY3R4LFxuICBvcHRpb25zLFxuICBjYWxsYmFjayxcbikge1xuICBjb25zdCBjdHhXaXRoU3BhbkNvbnRleHQgPSBlbnN1cmVTY29wZXNPbkNvbnRleHQoZ2V0Q29udGV4dFdpdGhSZW1vdGVBY3RpdmVTcGFuKGN0eCwgb3B0aW9ucykpO1xuXG4gIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eFdpdGhTcGFuQ29udGV4dCwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVTY29wZXNPbkNvbnRleHQoY3R4KSB7XG4gIC8vIElmIHRoZXJlIGFyZSBubyBzY29wZXMgeWV0IG9uIHRoZSBjb250ZXh0LCBlbnN1cmUgd2UgaGF2ZSB0aGVtXG4gIGNvbnN0IHNjb3BlcyA9IGdldFNjb3Blc0Zyb21Db250ZXh0KGN0eCk7XG4gIGNvbnN0IG5ld1Njb3BlcyA9IHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vIHNjb3BlIGhlcmUsIHRoaXMgaXMgbW9zdCBsaWtlbHkgZWl0aGVyIHRoZSByb290IGNvbnRleHQgb3IgYSBjb250ZXh0IG1hbnVhbGx5IGRlcml2ZWQgZnJvbSBpdFxuICAgIC8vIEluIHRoaXMgY2FzZSwgd2Ugd2FudCB0byBmb3JrIHRoZSBjdXJyZW50IHNjb3BlLCB0byBlbnN1cmUgd2UgZG8gbm90IHBvbGx1dGUgdGhlIHJvb3Qgc2NvcGVcbiAgICBzY29wZTogc2NvcGVzID8gc2NvcGVzLnNjb3BlIDogY29yZS5nZXRDdXJyZW50U2NvcGUoKS5jbG9uZSgpLFxuICAgIGlzb2xhdGlvblNjb3BlOiBzY29wZXMgPyBzY29wZXMuaXNvbGF0aW9uU2NvcGUgOiBjb3JlLmdldElzb2xhdGlvblNjb3BlKCksXG4gIH07XG5cbiAgcmV0dXJuIHNldFNjb3Blc09uQ29udGV4dChjdHgsIG5ld1Njb3Blcyk7XG59XG5cbi8qKiBUcnkgdG8gZ2V0IHRoZSBleGlzdGluZyBiYWdnYWdlIGhlYWRlciBzbyB3ZSBjYW4gbWVyZ2UgdGhpcyBpbi4gKi9cbmZ1bmN0aW9uIGdldEV4aXN0aW5nQmFnZ2FnZShjYXJyaWVyKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYmFnZ2FnZSA9IChjYXJyaWVyIClbU0VOVFJZX0JBR0dBR0VfSEVBREVSXTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShiYWdnYWdlKSA/IGJhZ2dhZ2Uuam9pbignLCcpIDogYmFnZ2FnZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEl0IGlzIHByZXR0eSB0cmlja3kgdG8gZ2V0IGFjY2VzcyB0byB0aGUgb3V0Z29pbmcgcmVxdWVzdCBVUkwgb2YgYSByZXF1ZXN0IGluIHRoZSBwcm9wYWdhdG9yLlxuICogQXMgd2Ugb25seSBoYXZlIGFjY2VzcyB0byB0aGUgY29udGV4dCBvZiB0aGUgc3BhbiB0byBiZSBzZW50IGFuZCB0aGUgY2FycmllciAoPWhlYWRlcnMpLFxuICogYnV0IHRoZSBzcGFuIG1heSBiZSB1bnNhbXBsZWQgYW5kIHRodXMgaGF2ZSBubyBhdHRyaWJ1dGVzLlxuICpcbiAqIFNvIHdlIHVzZSB0aGUgZm9sbG93aW5nIGxvZ2ljOlxuICogMS4gSWYgd2UgaGF2ZSBhbiBhY3RpdmUgc3Bhbiwgd2UgY2hlY2sgaWYgaXQgaGFzIGEgVVJMIGF0dHJpYnV0ZS5cbiAqIDIuIEVsc2UsIGlmIHRoZSBhY3RpdmUgc3BhbiBoYXMgbm8gVVJMIGF0dHJpYnV0ZSAoZS5nLiBpdCBpcyB1bnNhbXBsZWQpLCB3ZSBjaGVjayBhIHNwZWNpYWwgdHJhY2Ugc3RhdGUgKHdoaWNoIHdlIHNldCBpbiBvdXIgc2FtcGxlcikuXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnRVUkwoc3Bhbikge1xuICBjb25zdCBzcGFuRGF0YSA9IGNvcmUuc3BhblRvSlNPTihzcGFuKS5kYXRhO1xuICAvLyBgQVRUUl9VUkxfRlVMTGAgaXMgdGhlIG5ldyBhdHRyaWJ1dGUsIGJ1dCB3ZSBzdGlsbCBzdXBwb3J0IHRoZSBvbGQgb25lLCBgU0VNQVRUUlNfSFRUUF9VUkxgLCBmb3Igbm93LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgdXJsQXR0cmlidXRlID0gc3BhbkRhdGFbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1VSTF0gfHwgc3BhbkRhdGFbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX1VSTF9GVUxMXTtcbiAgaWYgKHR5cGVvZiB1cmxBdHRyaWJ1dGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHVybEF0dHJpYnV0ZTtcbiAgfVxuXG4gIC8vIEFsc28gbG9vayBhdCB0aGUgdHJhY2VTdGF0ZSwgd2hpY2ggd2UgbWF5IHNldCBpbiB0aGUgc2FtcGxlciBldmVuIGZvciB1bnNhbXBsZWQgc3BhbnNcbiAgY29uc3QgdXJsVHJhY2VTdGF0ZSA9IHNwYW4uc3BhbkNvbnRleHQoKS50cmFjZVN0YXRlPy5nZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1VSTCk7XG4gIGlmICh1cmxUcmFjZVN0YXRlKSB7XG4gICAgcmV0dXJuIHVybFRyYWNlU3RhdGU7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVJlbW90ZVNwYW5Db250ZXh0KHtcbiAgc3BhbklkLFxuICB0cmFjZUlkLFxuICBzYW1wbGVkLFxuICBkc2MsXG59XG5cbikge1xuICAvLyBXZSBzdG9yZSB0aGUgRFNDIGFzIE9URUwgdHJhY2Ugc3RhdGUgb24gdGhlIHNwYW4gY29udGV4dFxuICBjb25zdCB0cmFjZVN0YXRlID0gbWFrZVRyYWNlU3RhdGUoe1xuICAgIGRzYyxcbiAgICBzYW1wbGVkLFxuICB9KTtcblxuICBjb25zdCBzcGFuQ29udGV4dCA9IHtcbiAgICB0cmFjZUlkLFxuICAgIHNwYW5JZCxcbiAgICBpc1JlbW90ZTogdHJ1ZSxcbiAgICB0cmFjZUZsYWdzOiBzYW1wbGVkID8gYXBpLlRyYWNlRmxhZ3MuU0FNUExFRCA6IGFwaS5UcmFjZUZsYWdzLk5PTkUsXG4gICAgdHJhY2VTdGF0ZSxcbiAgfTtcblxuICByZXR1cm4gc3BhbkNvbnRleHQ7XG59XG5cbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiB3aXRoIGEgdHJhbnNhY3Rpb24vc3BhbiBhbmQgZmluaXNoZXMgdGhlIHNwYW4gYWZ0ZXIgdGhlIGZ1bmN0aW9uIGlzIGRvbmUuXG4gKiBUaGUgY3JlYXRlZCBzcGFuIGlzIHRoZSBhY3RpdmUgc3BhbiBhbmQgd2lsbCBiZSB1c2VkIGFzIHBhcmVudCBieSBvdGhlciBzcGFucyBjcmVhdGVkIGluc2lkZSB0aGUgZnVuY3Rpb25cbiAqIGFuZCBjYW4gYmUgYWNjZXNzZWQgdmlhIGBTZW50cnkuZ2V0QWN0aXZlU3BhbigpYCwgYXMgbG9uZyBhcyB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2hpbGUgdGhlIHNjb3BlIGlzIGFjdGl2ZS5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBzcGFuIHRoYXQgaXMgbm90IHNldCBhcyBhY3RpdmUsIHVzZSB7QGxpbmsgc3RhcnRJbmFjdGl2ZVNwYW59LlxuICpcbiAqIFlvdSdsbCBhbHdheXMgZ2V0IGEgc3BhbiBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLFxuICogaXQgbWF5IGp1c3QgYmUgYSBub24tcmVjb3JkaW5nIHNwYW4gaWYgdGhlIHNwYW4gaXMgbm90IHNhbXBsZWQgb3IgaWYgdHJhY2luZyBpcyBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRTcGFuKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuXG4gIGNvbnN0IHsgbmFtZSwgcGFyZW50U3BhbjogY3VzdG9tUGFyZW50U3BhbiB9ID0gb3B0aW9ucztcblxuICAvLyBJZiBgb3B0aW9ucy5wYXJlbnRTcGFuYCBpcyBkZWZpbmVkLCB3ZSB3YW50IHRvIHdyYXAgdGhlIGNhbGxiYWNrIGluIGB3aXRoQWN0aXZlU3BhbmBcbiAgY29uc3Qgd3JhcHBlciA9IGdldEFjdGl2ZVNwYW5XcmFwcGVyKGN1c3RvbVBhcmVudFNwYW4pO1xuXG4gIHJldHVybiB3cmFwcGVyKCgpID0+IHtcbiAgICBjb25zdCBhY3RpdmVDdHggPSBnZXRDb250ZXh0KG9wdGlvbnMuc2NvcGUsIG9wdGlvbnMuZm9yY2VUcmFuc2FjdGlvbik7XG4gICAgY29uc3Qgc2hvdWxkU2tpcFNwYW4gPSBvcHRpb25zLm9ubHlJZlBhcmVudCAmJiAhYXBpLnRyYWNlLmdldFNwYW4oYWN0aXZlQ3R4KTtcbiAgICBjb25zdCBjdHggPSBzaG91bGRTa2lwU3BhbiA/IGNvcmUkMS5zdXBwcmVzc1RyYWNpbmcoYWN0aXZlQ3R4KSA6IGFjdGl2ZUN0eDtcblxuICAgIGNvbnN0IHNwYW5PcHRpb25zID0gZ2V0U3Bhbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbihuYW1lLCBzcGFuT3B0aW9ucywgY3R4LCBzcGFuID0+IHtcbiAgICAgIHJldHVybiBjb3JlLmhhbmRsZUNhbGxiYWNrRXJyb3JzKFxuICAgICAgICAoKSA9PiBjYWxsYmFjayhzcGFuKSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIC8vIE9ubHkgc2V0IHRoZSBzcGFuIHN0YXR1cyB0byBFUlJPUiB3aGVuIHRoZXJlIHdhc24ndCBhbnkgc3RhdHVzIHNldCBiZWZvcmUsIGluIG9yZGVyIHRvIGF2b2lkIHN0b21waW5nIHVzZWZ1bCBzcGFuIHN0YXR1c2VzXG4gICAgICAgICAgaWYgKGNvcmUuc3BhblRvSlNPTihzcGFuKS5zdGF0dXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBhcGkuU3BhblN0YXR1c0NvZGUuRVJST1IgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAoKSA9PiBzcGFuLmVuZCgpLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBgU2VudHJ5LnN0YXJ0U3BhbmAuIFdyYXBzIGEgZnVuY3Rpb24gd2l0aCBhIHNwYW4sIGJ1dCBkb2VzIG5vdCBmaW5pc2ggdGhlIHNwYW5cbiAqIGFmdGVyIHRoZSBmdW5jdGlvbiBpcyBkb25lIGF1dG9tYXRpY2FsbHkuIFlvdSdsbCBoYXZlIHRvIGNhbGwgYHNwYW4uZW5kKClgIG1hbnVhbGx5LlxuICpcbiAqIFRoZSBjcmVhdGVkIHNwYW4gaXMgdGhlIGFjdGl2ZSBzcGFuIGFuZCB3aWxsIGJlIHVzZWQgYXMgcGFyZW50IGJ5IG90aGVyIHNwYW5zIGNyZWF0ZWQgaW5zaWRlIHRoZSBmdW5jdGlvblxuICogYW5kIGNhbiBiZSBhY2Nlc3NlZCB2aWEgYFNlbnRyeS5nZXRBY3RpdmVTcGFuKClgLCBhcyBsb25nIGFzIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aGlsZSB0aGUgc2NvcGUgaXMgYWN0aXZlLlxuICpcbiAqIFlvdSdsbCBhbHdheXMgZ2V0IGEgc3BhbiBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLFxuICogaXQgbWF5IGp1c3QgYmUgYSBub24tcmVjb3JkaW5nIHNwYW4gaWYgdGhlIHNwYW4gaXMgbm90IHNhbXBsZWQgb3IgaWYgdHJhY2luZyBpcyBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRTcGFuTWFudWFsKFxuICBvcHRpb25zLFxuICBjYWxsYmFjayxcbikge1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoKTtcblxuICBjb25zdCB7IG5hbWUsIHBhcmVudFNwYW46IGN1c3RvbVBhcmVudFNwYW4gfSA9IG9wdGlvbnM7XG5cbiAgLy8gSWYgYG9wdGlvbnMucGFyZW50U3BhbmAgaXMgZGVmaW5lZCwgd2Ugd2FudCB0byB3cmFwIHRoZSBjYWxsYmFjayBpbiBgd2l0aEFjdGl2ZVNwYW5gXG4gIGNvbnN0IHdyYXBwZXIgPSBnZXRBY3RpdmVTcGFuV3JhcHBlcihjdXN0b21QYXJlbnRTcGFuKTtcblxuICByZXR1cm4gd3JhcHBlcigoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlQ3R4ID0gZ2V0Q29udGV4dChvcHRpb25zLnNjb3BlLCBvcHRpb25zLmZvcmNlVHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHNob3VsZFNraXBTcGFuID0gb3B0aW9ucy5vbmx5SWZQYXJlbnQgJiYgIWFwaS50cmFjZS5nZXRTcGFuKGFjdGl2ZUN0eCk7XG4gICAgY29uc3QgY3R4ID0gc2hvdWxkU2tpcFNwYW4gPyBjb3JlJDEuc3VwcHJlc3NUcmFjaW5nKGFjdGl2ZUN0eCkgOiBhY3RpdmVDdHg7XG5cbiAgICBjb25zdCBzcGFuT3B0aW9ucyA9IGdldFNwYW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4obmFtZSwgc3Bhbk9wdGlvbnMsIGN0eCwgc3BhbiA9PiB7XG4gICAgICByZXR1cm4gY29yZS5oYW5kbGVDYWxsYmFja0Vycm9ycyhcbiAgICAgICAgKCkgPT4gY2FsbGJhY2soc3BhbiwgKCkgPT4gc3Bhbi5lbmQoKSksXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBPbmx5IHNldCB0aGUgc3BhbiBzdGF0dXMgdG8gRVJST1Igd2hlbiB0aGVyZSB3YXNuJ3QgYW55IHN0YXR1cyBzZXQgYmVmb3JlLCBpbiBvcmRlciB0byBhdm9pZCBzdG9tcGluZyB1c2VmdWwgc3BhbiBzdGF0dXNlc1xuICAgICAgICAgIGlmIChjb3JlLnNwYW5Ub0pTT04oc3Bhbikuc3RhdHVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogYXBpLlNwYW5TdGF0dXNDb2RlLkVSUk9SIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzcGFuLiBUaGlzIHNwYW4gaXMgbm90IHNldCBhcyBhY3RpdmUsIHNvIHdpbGwgbm90IGdldCBhdXRvbWF0aWMgaW5zdHJ1bWVudGF0aW9uIHNwYW5zXG4gKiBhcyBjaGlsZHJlbiBvciBiZSBhYmxlIHRvIGJlIGFjY2Vzc2VkIHZpYSBgU2VudHJ5LmdldEFjdGl2ZVNwYW4oKWAuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgc3BhbiB0aGF0IGlzIHNldCBhcyBhY3RpdmUsIHVzZSB7QGxpbmsgc3RhcnRTcGFufS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIHJldHVybiBhIHNwYW4sXG4gKiBpdCBtYXkganVzdCBiZSBhIG5vbi1yZWNvcmRpbmcgc3BhbiBpZiB0aGUgc3BhbiBpcyBub3Qgc2FtcGxlZCBvciBpZiB0cmFjaW5nIGlzIGRpc2FibGVkLlxuICovXG5mdW5jdGlvbiBzdGFydEluYWN0aXZlU3BhbihvcHRpb25zKSB7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuXG4gIGNvbnN0IHsgbmFtZSwgcGFyZW50U3BhbjogY3VzdG9tUGFyZW50U3BhbiB9ID0gb3B0aW9ucztcblxuICAvLyBJZiBgb3B0aW9ucy5wYXJlbnRTcGFuYCBpcyBkZWZpbmVkLCB3ZSB3YW50IHRvIHdyYXAgdGhlIGNhbGxiYWNrIGluIGB3aXRoQWN0aXZlU3BhbmBcbiAgY29uc3Qgd3JhcHBlciA9IGdldEFjdGl2ZVNwYW5XcmFwcGVyKGN1c3RvbVBhcmVudFNwYW4pO1xuXG4gIHJldHVybiB3cmFwcGVyKCgpID0+IHtcbiAgICBjb25zdCBhY3RpdmVDdHggPSBnZXRDb250ZXh0KG9wdGlvbnMuc2NvcGUsIG9wdGlvbnMuZm9yY2VUcmFuc2FjdGlvbik7XG4gICAgY29uc3Qgc2hvdWxkU2tpcFNwYW4gPSBvcHRpb25zLm9ubHlJZlBhcmVudCAmJiAhYXBpLnRyYWNlLmdldFNwYW4oYWN0aXZlQ3R4KTtcbiAgICBjb25zdCBjdHggPSBzaG91bGRTa2lwU3BhbiA/IGNvcmUkMS5zdXBwcmVzc1RyYWNpbmcoYWN0aXZlQ3R4KSA6IGFjdGl2ZUN0eDtcblxuICAgIGNvbnN0IHNwYW5PcHRpb25zID0gZ2V0U3Bhbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBjb25zdCBzcGFuID0gdHJhY2VyLnN0YXJ0U3BhbihuYW1lLCBzcGFuT3B0aW9ucywgY3R4KTtcblxuICAgIHJldHVybiBzcGFuO1xuICB9KTtcbn1cblxuLyoqXG4gKiBGb3JrcyB0aGUgY3VycmVudCBzY29wZSBhbmQgc2V0cyB0aGUgcHJvdmlkZWQgc3BhbiBhcyBhY3RpdmUgc3BhbiBpbiB0aGUgY29udGV4dCBvZiB0aGUgcHJvdmlkZWQgY2FsbGJhY2suIENhbiBiZVxuICogcGFzc2VkIGBudWxsYCB0byBzdGFydCBhbiBlbnRpcmVseSBuZXcgc3BhbiB0cmVlLlxuICpcbiAqIEBwYXJhbSBzcGFuIFNwYW5zIHN0YXJ0ZWQgaW4gdGhlIGNvbnRleHQgb2YgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmUgY2hpbGRyZW4gb2YgdGhpcyBzcGFuLiBJZiBgbnVsbGAgaXMgcGFzc2VkLFxuICogc3BhbnMgc3RhcnRlZCB3aXRoaW4gdGhlIGNhbGxiYWNrIHdpbGwgYmUgcm9vdCBzcGFucy5cbiAqIEBwYXJhbSBjYWxsYmFjayBFeGVjdXRpb24gY29udGV4dCBpbiB3aGljaCB0aGUgcHJvdmlkZWQgc3BhbiB3aWxsIGJlIGFjdGl2ZS4gSXMgcGFzc2VkIHRoZSBuZXdseSBmb3JrZWQgc2NvcGUuXG4gKiBAcmV0dXJucyB0aGUgdmFsdWUgcmV0dXJuZWQgZnJvbSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHdpdGhBY3RpdmVTcGFuKHNwYW4sIGNhbGxiYWNrKSB7XG4gIGNvbnN0IG5ld0NvbnRleHRXaXRoQWN0aXZlU3BhbiA9IHNwYW4gPyBhcGkudHJhY2Uuc2V0U3BhbihhcGkuY29udGV4dC5hY3RpdmUoKSwgc3BhbikgOiBhcGkudHJhY2UuZGVsZXRlU3BhbihhcGkuY29udGV4dC5hY3RpdmUoKSk7XG4gIHJldHVybiBhcGkuY29udGV4dC53aXRoKG5ld0NvbnRleHRXaXRoQWN0aXZlU3BhbiwgKCkgPT4gY2FsbGJhY2soY29yZS5nZXRDdXJyZW50U2NvcGUoKSkpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFjZXIoKSB7XG4gIGNvbnN0IGNsaWVudCA9IGNvcmUuZ2V0Q2xpZW50KCk7XG4gIHJldHVybiBjbGllbnQ/LnRyYWNlciB8fCBhcGkudHJhY2UuZ2V0VHJhY2VyKCdAc2VudHJ5L29wZW50ZWxlbWV0cnknLCBjb3JlLlNES19WRVJTSU9OKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3Bhbk9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCB7IHN0YXJ0VGltZSwgYXR0cmlidXRlcywga2luZCwgb3AsIGxpbmtzIH0gPSBvcHRpb25zO1xuXG4gIC8vIE9URUwgZXhwZWN0cyB0aW1lc3RhbXBzIGluIG1zLCBub3Qgc2Vjb25kc1xuICBjb25zdCBmaXhlZFN0YXJ0VGltZSA9IHR5cGVvZiBzdGFydFRpbWUgPT09ICdudW1iZXInID8gZW5zdXJlVGltZXN0YW1wSW5NaWxsaXNlY29uZHMoc3RhcnRUaW1lKSA6IHN0YXJ0VGltZTtcblxuICByZXR1cm4ge1xuICAgIGF0dHJpYnV0ZXM6IG9wXG4gICAgICA/IHtcbiAgICAgICAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXTogb3AsXG4gICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgfVxuICAgICAgOiBhdHRyaWJ1dGVzLFxuICAgIGtpbmQsXG4gICAgbGlua3MsXG4gICAgc3RhcnRUaW1lOiBmaXhlZFN0YXJ0VGltZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlVGltZXN0YW1wSW5NaWxsaXNlY29uZHModGltZXN0YW1wKSB7XG4gIGNvbnN0IGlzTXMgPSB0aW1lc3RhbXAgPCA5OTk5OTk5OTk5O1xuICByZXR1cm4gaXNNcyA/IHRpbWVzdGFtcCAqIDEwMDAgOiB0aW1lc3RhbXA7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoc2NvcGUsIGZvcmNlVHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dEZvclNjb3BlKHNjb3BlKTtcbiAgY29uc3QgcGFyZW50U3BhbiA9IGFwaS50cmFjZS5nZXRTcGFuKGN0eCk7XG5cbiAgLy8gSW4gdGhlIGNhc2UgdGhhdCB3ZSBoYXZlIG5vIHBhcmVudCBzcGFuLCB3ZSBzdGFydCBhIG5ldyB0cmFjZVxuICAvLyBOb3RlIHRoYXQgaWYgd2UgY29udGludWUgYSB0cmFjZSwgd2UnbGwgYWx3YXlzIGhhdmUgYSByZW1vdGUgcGFyZW50IHNwYW4gaGVyZSBhbnlob3dcbiAgaWYgKCFwYXJlbnRTcGFuKSB7XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxuXG4gIC8vIElmIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgYSB0cmFuc2FjdGlvbiwgYW5kIHdlIGhhdmUgYSBwYXJlbnQgc3BhbiwgYWxsIGdvb2QsIHdlIGp1c3QgcmV0dXJuIGFzLWlzIVxuICBpZiAoIWZvcmNlVHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4gY3R4O1xuICB9XG5cbiAgLy8gRWxzZSwgaWYgd2UgZG8gaGF2ZSBhIHBhcmVudCBzcGFuIGJ1dCB3YW50IHRvIGZvcmNlIGEgdHJhbnNhY3Rpb24sIHdlIGhhdmUgdG8gc2ltdWxhdGUgYSBcInJvb3RcIiBjb250ZXh0XG5cbiAgLy8gRWxzZSwgd2UgbmVlZCB0byBkbyB0d28gdGhpbmdzOlxuICAvLyAxLiBVbnNldCB0aGUgcGFyZW50IHNwYW4gZnJvbSB0aGUgY29udGV4dCwgc28gd2UnbGwgY3JlYXRlIGEgbmV3IHJvb3Qgc3BhblxuICAvLyAyLiBFbnN1cmUgdGhlIHByb3BhZ2F0aW9uIGNvbnRleHQgaXMgY29ycmVjdCwgc28gd2UnbGwgY29udGludWUgZnJvbSB0aGUgcGFyZW50IHNwYW5cbiAgY29uc3QgY3R4V2l0aG91dFNwYW4gPSBhcGkudHJhY2UuZGVsZXRlU3BhbihjdHgpO1xuXG4gIGNvbnN0IHsgc3BhbklkLCB0cmFjZUlkIH0gPSBwYXJlbnRTcGFuLnNwYW5Db250ZXh0KCk7XG4gIGNvbnN0IHNhbXBsZWQgPSBnZXRTYW1wbGluZ0RlY2lzaW9uKHBhcmVudFNwYW4uc3BhbkNvbnRleHQoKSk7XG5cbiAgLy8gSW4gdGhpcyBjYXNlLCB3aGVuIHdlIGFyZSBmb3JjaW5nIGEgdHJhbnNhY3Rpb24sIHdlIHdhbnQgdG8gdHJlYXQgdGhpcyBsaWtlIGNvbnRpbnVpbmcgYW4gaW5jb21pbmcgdHJhY2VcbiAgLy8gc28gd2Ugc2V0IHRoZSB0cmFjZVN0YXRlIGFjY29yZGluZyB0byB0aGUgcm9vdCBzcGFuXG4gIGNvbnN0IHJvb3RTcGFuID0gY29yZS5nZXRSb290U3BhbihwYXJlbnRTcGFuKTtcbiAgY29uc3QgZHNjID0gY29yZS5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4ocm9vdFNwYW4pO1xuXG4gIGNvbnN0IHRyYWNlU3RhdGUgPSBtYWtlVHJhY2VTdGF0ZSh7XG4gICAgZHNjLFxuICAgIHNhbXBsZWQsXG4gIH0pO1xuXG4gIGNvbnN0IHNwYW5PcHRpb25zID0ge1xuICAgIHRyYWNlSWQsXG4gICAgc3BhbklkLFxuICAgIGlzUmVtb3RlOiB0cnVlLFxuICAgIHRyYWNlRmxhZ3M6IHNhbXBsZWQgPyBhcGkuVHJhY2VGbGFncy5TQU1QTEVEIDogYXBpLlRyYWNlRmxhZ3MuTk9ORSxcbiAgICB0cmFjZVN0YXRlLFxuICB9O1xuXG4gIGNvbnN0IGN0eFdpdGhTcGFuQ29udGV4dCA9IGFwaS50cmFjZS5zZXRTcGFuQ29udGV4dChjdHhXaXRob3V0U3Bhbiwgc3Bhbk9wdGlvbnMpO1xuXG4gIHJldHVybiBjdHhXaXRoU3BhbkNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JTY29wZShzY29wZSkge1xuICBpZiAoc2NvcGUpIHtcbiAgICBjb25zdCBjdHggPSBnZXRDb250ZXh0RnJvbVNjb3BlKHNjb3BlKTtcbiAgICBpZiAoY3R4KSB7XG4gICAgICByZXR1cm4gY3R4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcGkuY29udGV4dC5hY3RpdmUoKTtcbn1cblxuLyoqXG4gKiBDb250aW51ZSBhIHRyYWNlIGZyb20gYHNlbnRyeS10cmFjZWAgYW5kIGBiYWdnYWdlYCB2YWx1ZXMuXG4gKiBUaGVzZSB2YWx1ZXMgY2FuIGJlIG9idGFpbmVkIGZyb20gaW5jb21pbmcgcmVxdWVzdCBoZWFkZXJzLCBvciBpbiB0aGUgYnJvd3NlciBmcm9tIGA8bWV0YSBuYW1lPVwic2VudHJ5LXRyYWNlXCI+YFxuICogYW5kIGA8bWV0YSBuYW1lPVwiYmFnZ2FnZVwiPmAgSFRNTCB0YWdzLlxuICpcbiAqIFNwYW5zIHN0YXJ0ZWQgd2l0aCBgc3RhcnRTcGFuYCwgYHN0YXJ0U3Bhbk1hbnVhbGAgYW5kIGBzdGFydEluYWN0aXZlU3BhbmAsIHdpdGhpbiB0aGUgY2FsbGJhY2sgd2lsbCBhdXRvbWF0aWNhbGx5XG4gKiBiZSBhdHRhY2hlZCB0byB0aGUgaW5jb21pbmcgdHJhY2UuXG4gKlxuICogVGhpcyBpcyBhIGN1c3RvbSB2ZXJzaW9uIG9mIGBjb250aW51ZVRyYWNlYCB0aGF0IGlzIHVzZWQgaW4gT1RFTC1wb3dlcmVkIGVudmlyb25tZW50cy5cbiAqIEl0IHByb3BhZ2F0ZXMgdGhlIHRyYWNlIGFzIGEgcmVtb3RlIHNwYW4sIGluIGFkZGl0aW9uIHRvIHNldHRpbmcgaXQgb24gdGhlIHByb3BhZ2F0aW9uIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGNvbnRpbnVlVHJhY2Uob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNvbnRpbnVlVHJhY2VBc1JlbW90ZVNwYW4oYXBpLmNvbnRleHQuYWN0aXZlKCksIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRyYWNlIGNvbnRleHQgZm9yIGEgZ2l2ZW4gc2NvcGUuXG4gKiBXZSBoYXZlIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uIGhlcmUgYmVjYXVzZSB3ZSBuZWVkIGFuIE9URUwtc3BlY2lmaWMgd2F5IHRvIGdldCB0aGUgc3BhbiBmcm9tIGEgc2NvcGUuXG4gKi9cbmZ1bmN0aW9uIGdldFRyYWNlQ29udGV4dEZvclNjb3BlKFxuICBjbGllbnQsXG4gIHNjb3BlLFxuKSB7XG4gIGNvbnN0IGN0eCA9IGdldENvbnRleHRGcm9tU2NvcGUoc2NvcGUpO1xuICBjb25zdCBzcGFuID0gY3R4ICYmIGFwaS50cmFjZS5nZXRTcGFuKGN0eCk7XG5cbiAgY29uc3QgdHJhY2VDb250ZXh0ID0gc3BhbiA/IGNvcmUuc3BhblRvVHJhY2VDb250ZXh0KHNwYW4pIDogY29yZS5nZXRUcmFjZUNvbnRleHRGcm9tU2NvcGUoc2NvcGUpO1xuXG4gIGNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSBzcGFuXG4gICAgPyBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuKVxuICAgIDogY29yZS5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNjb3BlKGNsaWVudCwgc2NvcGUpO1xuICByZXR1cm4gW2R5bmFtaWNTYW1wbGluZ0NvbnRleHQsIHRyYWNlQ29udGV4dF07XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZVNwYW5XcmFwcGVyKHBhcmVudFNwYW4pIHtcbiAgcmV0dXJuIHBhcmVudFNwYW4gIT09IHVuZGVmaW5lZFxuICAgID8gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHJldHVybiB3aXRoQWN0aXZlU3BhbihwYXJlbnRTcGFuLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgOiAoY2FsbGJhY2spID0+IGNhbGxiYWNrKCk7XG59XG5cbi8qKiBTdXBwcmVzcyB0cmFjaW5nIGluIHRoZSBnaXZlbiBjYWxsYmFjaywgZW5zdXJpbmcgbm8gc3BhbnMgYXJlIGdlbmVyYXRlZCBpbnNpZGUgb2YgaXQuICovXG5mdW5jdGlvbiBzdXBwcmVzc1RyYWNpbmcoY2FsbGJhY2spIHtcbiAgY29uc3QgY3R4ID0gY29yZSQxLnN1cHByZXNzVHJhY2luZyhhcGkuY29udGV4dC5hY3RpdmUoKSk7XG4gIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eCwgY2FsbGJhY2spO1xufVxuXG4vKiogRW5zdXJlIHRoZSBgdHJhY2VgIGNvbnRleHQgaXMgc2V0IG9uIGFsbCBldmVudHMuICovXG5mdW5jdGlvbiBzZXR1cEV2ZW50Q29udGV4dFRyYWNlKGNsaWVudCkge1xuICBjbGllbnQub24oJ3ByZXByb2Nlc3NFdmVudCcsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzcGFuID0gZ2V0QWN0aXZlU3BhbigpO1xuICAgIC8vIEZvciB0cmFuc2FjdGlvbiBldmVudHMsIHRoaXMgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5XG4gICAgLy8gQmVjYXVzZSB0aGUgYWN0aXZlIHNwYW4gbWF5IG5vdCBiZSB0aGUgc3BhbiB0aGF0IGlzIGFjdHVhbGx5IHRoZSB0cmFuc2FjdGlvbiBldmVudFxuICAgIGlmICghc3BhbiB8fCBldmVudC50eXBlID09PSAndHJhbnNhY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgZXZlbnQgaGFzIGFscmVhZHkgc2V0IGB0cmFjZWAgY29udGV4dCwgdXNlIHRoYXQgb25lLlxuICAgIGV2ZW50LmNvbnRleHRzID0ge1xuICAgICAgdHJhY2U6IGNvcmUuc3BhblRvVHJhY2VDb250ZXh0KHNwYW4pLFxuICAgICAgLi4uZXZlbnQuY29udGV4dHMsXG4gICAgfTtcblxuICAgIGNvbnN0IHJvb3RTcGFuID0gY29yZS5nZXRSb290U3BhbihzcGFuKTtcblxuICAgIGV2ZW50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IHtcbiAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQ6IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHJvb3RTcGFuKSxcbiAgICAgIC4uLmV2ZW50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGV2ZW50O1xuICB9KTtcbn1cblxuLyoqXG4gKiBPdGVsLXNwZWNpZmljIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUcmFjZURhdGFgLlxuICogQHNlZSBgQHNlbnRyeS9jb3JlYCB2ZXJzaW9uIG9mIGBnZXRUcmFjZURhdGFgIGZvciBtb3JlIGluZm9ybWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFRyYWNlRGF0YSh7XG4gIHNwYW4sXG4gIHNjb3BlLFxuICBjbGllbnQsXG59ID0ge30pIHtcbiAgbGV0IGN0eCA9IChzY29wZSAmJiBnZXRDb250ZXh0RnJvbVNjb3BlKHNjb3BlKSkgPz8gYXBpLmNvbnRleHQuYWN0aXZlKCk7XG5cbiAgaWYgKHNwYW4pIHtcbiAgICBjb25zdCB7IHNjb3BlIH0gPSBjb3JlLmdldENhcHR1cmVkU2NvcGVzT25TcGFuKHNwYW4pO1xuICAgIC8vIGZhbGwgYmFjayB0byBjdXJyZW50IGNvbnRleHQgaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB3ZSBjYW4ndCBmaW5kIHRoZSBvbmUgb2YgdGhlIHNwYW5cbiAgICBjdHggPSAoc2NvcGUgJiYgZ2V0Q29udGV4dEZyb21TY29wZShzY29wZSkpIHx8IGFwaS50cmFjZS5zZXRTcGFuKGFwaS5jb250ZXh0LmFjdGl2ZSgpLCBzcGFuKTtcbiAgfVxuXG4gIGNvbnN0IHsgdHJhY2VJZCwgc3BhbklkLCBzYW1wbGVkLCBkeW5hbWljU2FtcGxpbmdDb250ZXh0IH0gPSBnZXRJbmplY3Rpb25EYXRhKGN0eCwgeyBzY29wZSwgY2xpZW50IH0pO1xuXG4gIHJldHVybiB7XG4gICAgJ3NlbnRyeS10cmFjZSc6IGNvcmUuZ2VuZXJhdGVTZW50cnlUcmFjZUhlYWRlcih0cmFjZUlkLCBzcGFuSWQsIHNhbXBsZWQpLFxuICAgIGJhZ2dhZ2U6IGNvcmUuZHluYW1pY1NhbXBsaW5nQ29udGV4dFRvU2VudHJ5QmFnZ2FnZUhlYWRlcihkeW5hbWljU2FtcGxpbmdDb250ZXh0KSxcbiAgfTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBhc3luYyBjb250ZXh0IHN0cmF0ZWd5IHRvIHVzZSBmb2xsb3cgdGhlIE9URUwgY29udGV4dCB1bmRlciB0aGUgaG9vZC5cbiAqIFdlIGhhbmRsZSBmb3JraW5nIGEgaHViIGluc2lkZSBvZiBvdXIgY3VzdG9tIE9URUwgQ29udGV4dCBNYW5hZ2VyICguL290ZWxDb250ZXh0TWFuYWdlci50cylcbiAqL1xuZnVuY3Rpb24gc2V0T3BlblRlbGVtZXRyeUNvbnRleHRBc3luY0NvbnRleHRTdHJhdGVneSgpIHtcbiAgZnVuY3Rpb24gZ2V0U2NvcGVzKCkge1xuICAgIGNvbnN0IGN0eCA9IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuICAgIGNvbnN0IHNjb3BlcyA9IGdldFNjb3Blc0Zyb21Db250ZXh0KGN0eCk7XG5cbiAgICBpZiAoc2NvcGVzKSB7XG4gICAgICByZXR1cm4gc2NvcGVzO1xuICAgIH1cblxuICAgIC8vIGZhbGxiYWNrIGJlaGF2aW9yOlxuICAgIC8vIGlmLCBmb3Igd2hhdGV2ZXIgcmVhc29uLCB3ZSBjYW4ndCBmaW5kIHNjb3BlcyBvbiB0aGUgY29udGV4dCBoZXJlLCB3ZSBoYXZlIHRvIGZpeCB0aGlzIHNvbWVob3dcbiAgICByZXR1cm4ge1xuICAgICAgc2NvcGU6IGNvcmUuZ2V0RGVmYXVsdEN1cnJlbnRTY29wZSgpLFxuICAgICAgaXNvbGF0aW9uU2NvcGU6IGNvcmUuZ2V0RGVmYXVsdElzb2xhdGlvblNjb3BlKCksXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhTY29wZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGN0eCA9IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuXG4gICAgLy8gV2UgZGVwZW5kIG9uIHRoZSBvdGVsQ29udGV4dE1hbmFnZXIgdG8gaGFuZGxlIHRoZSBjb250ZXh0L2h1YlxuICAgIC8vIFdlIHNldCB0aGUgYFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWWAgY29udGV4dCB2YWx1ZSwgd2hpY2ggaXMgcGlja2VkIHVwIGJ5XG4gICAgLy8gdGhlIE9URUwgY29udGV4dCBtYW5hZ2VyLCB3aGljaCB1c2VzIHRoZSBwcmVzZW5jZSBvZiB0aGlzIGtleSB0byBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkXG4gICAgLy8gZm9yayB0aGUgaXNvbGF0aW9uIHNjb3BlLCBvciBub3RcbiAgICAvLyBhcyBieSBkZWZhdWx0LCB3ZSBkb24ndCB3YW50IHRvIGZvcmsgdGhpcywgdW5sZXNzIHRyaWdnZXJlZCBleHBsaWNpdGx5IGJ5IGB3aXRoU2NvcGVgXG4gICAgcmV0dXJuIGFwaS5jb250ZXh0LndpdGgoY3R4LCAoKSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZ2V0Q3VycmVudFNjb3BlKCkpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aFNldFNjb3BlKHNjb3BlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGN0eCA9IGdldENvbnRleHRGcm9tU2NvcGUoc2NvcGUpIHx8IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuXG4gICAgLy8gV2UgZGVwZW5kIG9uIHRoZSBvdGVsQ29udGV4dE1hbmFnZXIgdG8gaGFuZGxlIHRoZSBjb250ZXh0L2h1YlxuICAgIC8vIFdlIHNldCB0aGUgYFNFTlRSWV9GT1JLX1NFVF9TQ09QRV9DT05URVhUX0tFWWAgY29udGV4dCB2YWx1ZSwgd2hpY2ggaXMgcGlja2VkIHVwIGJ5XG4gICAgLy8gdGhlIE9URUwgY29udGV4dCBtYW5hZ2VyLCB3aGljaCBwaWNrcyB1cCB0aGlzIHNjb3BlIGFzIHRoZSBjdXJyZW50IHNjb3BlXG4gICAgcmV0dXJuIGFwaS5jb250ZXh0LndpdGgoY3R4LnNldFZhbHVlKFNFTlRSWV9GT1JLX1NFVF9TQ09QRV9DT05URVhUX0tFWSwgc2NvcGUpLCAoKSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soc2NvcGUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aElzb2xhdGlvblNjb3BlKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY3R4ID0gYXBpLmNvbnRleHQuYWN0aXZlKCk7XG5cbiAgICAvLyBXZSBkZXBlbmQgb24gdGhlIG90ZWxDb250ZXh0TWFuYWdlciB0byBoYW5kbGUgdGhlIGNvbnRleHQvaHViXG4gICAgLy8gV2Ugc2V0IHRoZSBgU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZYCBjb250ZXh0IHZhbHVlLCB3aGljaCBpcyBwaWNrZWQgdXAgYnlcbiAgICAvLyB0aGUgT1RFTCBjb250ZXh0IG1hbmFnZXIsIHdoaWNoIHVzZXMgdGhlIHByZXNlbmNlIG9mIHRoaXMga2V5IHRvIGRldGVybWluZSBpZiBpdCBzaG91bGRcbiAgICAvLyBmb3JrIHRoZSBpc29sYXRpb24gc2NvcGUsIG9yIG5vdFxuICAgIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eC5zZXRWYWx1ZShTRU5UUllfRk9SS19JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVksIHRydWUpLCAoKSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZ2V0SXNvbGF0aW9uU2NvcGUoKSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB3aXRoU2V0SXNvbGF0aW9uU2NvcGUoaXNvbGF0aW9uU2NvcGUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY3R4ID0gYXBpLmNvbnRleHQuYWN0aXZlKCk7XG5cbiAgICAvLyBXZSBkZXBlbmQgb24gdGhlIG90ZWxDb250ZXh0TWFuYWdlciB0byBoYW5kbGUgdGhlIGNvbnRleHQvaHViXG4gICAgLy8gV2Ugc2V0IHRoZSBgU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZYCBjb250ZXh0IHZhbHVlLCB3aGljaCBpcyBwaWNrZWQgdXAgYnlcbiAgICAvLyB0aGUgT1RFTCBjb250ZXh0IG1hbmFnZXIsIHdoaWNoIHVzZXMgdGhlIHByZXNlbmNlIG9mIHRoaXMga2V5IHRvIGRldGVybWluZSBpZiBpdCBzaG91bGRcbiAgICAvLyBmb3JrIHRoZSBpc29sYXRpb24gc2NvcGUsIG9yIG5vdFxuICAgIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eC5zZXRWYWx1ZShTRU5UUllfRk9SS19TRVRfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZLCBpc29sYXRpb25TY29wZSksICgpID0+IHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhnZXRJc29sYXRpb25TY29wZSgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgICByZXR1cm4gZ2V0U2NvcGVzKCkuc2NvcGU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJc29sYXRpb25TY29wZSgpIHtcbiAgICByZXR1cm4gZ2V0U2NvcGVzKCkuaXNvbGF0aW9uU2NvcGU7XG4gIH1cblxuICBjb3JlLnNldEFzeW5jQ29udGV4dFN0cmF0ZWd5KHtcbiAgICB3aXRoU2NvcGUsXG4gICAgd2l0aFNldFNjb3BlLFxuICAgIHdpdGhTZXRJc29sYXRpb25TY29wZSxcbiAgICB3aXRoSXNvbGF0aW9uU2NvcGUsXG4gICAgZ2V0Q3VycmVudFNjb3BlLFxuICAgIGdldElzb2xhdGlvblNjb3BlLFxuICAgIHN0YXJ0U3BhbixcbiAgICBzdGFydFNwYW5NYW51YWwsXG4gICAgc3RhcnRJbmFjdGl2ZVNwYW4sXG4gICAgZ2V0QWN0aXZlU3BhbixcbiAgICBzdXBwcmVzc1RyYWNpbmcsXG4gICAgZ2V0VHJhY2VEYXRhLFxuICAgIGNvbnRpbnVlVHJhY2UsXG4gICAgLy8gVGhlIHR5cGVzIGhlcmUgZG9uJ3QgZnVsbHkgYWxpZ24sIGJlY2F1c2Ugb3VyIG93biBgU3BhbmAgdHlwZSBpcyBuYXJyb3dlclxuICAgIC8vIHRoYW4gdGhlIE9URUwgb25lIC0gYnV0IHRoaXMgaXMgT0sgZm9yIGhlcmUsIGFzIHdlIG5vdyB3ZSdsbCBvbmx5IGhhdmUgT1RFTCBzcGFucyBwYXNzZWQgYXJvdW5kXG4gICAgd2l0aEFjdGl2ZVNwYW46IHdpdGhBY3RpdmVTcGFuICxcbiAgfSk7XG59XG5cbi8qKlxuICogV3JhcCBhbiBPcGVuVGVsZW1ldHJ5IENvbnRleHRNYW5hZ2VyIGluIGEgd2F5IHRoYXQgZW5zdXJlcyB0aGUgY29udGV4dCBpcyBrZXB0IGluIHN5bmMgd2l0aCB0aGUgU2VudHJ5IFNjb3BlLlxuICpcbiAqIFVzYWdlOlxuICogaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VDb250ZXh0TWFuYWdlciB9IGZyb20gJ0BvcGVudGVsZW1ldHJ5L2NvbnRleHQtYXN5bmMtaG9va3MnO1xuICogY29uc3QgU2VudHJ5Q29udGV4dE1hbmFnZXIgPSB3cmFwQ29udGV4dE1hbmFnZXJDbGFzcyhBc3luY0xvY2FsU3RvcmFnZUNvbnRleHRNYW5hZ2VyKTtcbiAqIGNvbnN0IGNvbnRleHRNYW5hZ2VyID0gbmV3IFNlbnRyeUNvbnRleHRNYW5hZ2VyKCk7XG4gKi9cbmZ1bmN0aW9uIHdyYXBDb250ZXh0TWFuYWdlckNsYXNzKFxuICBDb250ZXh0TWFuYWdlckNsYXNzLFxuKSB7XG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY3VzdG9tIENvbnRleHRNYW5hZ2VyIGZvciBPcGVuVGVsZW1ldHJ5LCB3aGljaCBleHRlbmRzIHRoZSBkZWZhdWx0IEFzeW5jTG9jYWxTdG9yYWdlQ29udGV4dE1hbmFnZXIuXG4gICAqIEl0IGVuc3VyZXMgdGhhdCB3ZSBjcmVhdGUgbmV3IHNjb3BlcyBwZXIgY29udGV4dCwgc28gdGhhdCB0aGUgT1RFTCBDb250ZXh0ICYgdGhlIFNlbnRyeSBTY29wZSBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB3ZSBjdXJyZW50bHkgb25seSBzdXBwb3J0IEFzeW5jSG9va3Mgd2l0aCB0aGlzLFxuICAgKiBidXQgc2luY2UgdGhpcyBzaG91bGQgd29yayBmb3IgTm9kZSAxNCsgYW55aG93IHRoYXQgc2hvdWxkIGJlIGdvb2QgZW5vdWdoLlxuICAgKi9cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGRvZXMgbm90IGxpa2UgdGhpcywgYnV0IHdlIGtub3cgdGhpcyBpcyBmaW5lXG4gIGNsYXNzIFNlbnRyeUNvbnRleHRNYW5hZ2VyIGV4dGVuZHMgQ29udGV4dE1hbmFnZXJDbGFzcyB7XG4gICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgc2V0SXNTZXR1cCgnU2VudHJ5Q29udGV4dE1hbmFnZXInKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcndyaXRlIHdpdGgoKSBvZiB0aGUgb3JpZ2luYWwgQXN5bmNMb2NhbFN0b3JhZ2VDb250ZXh0TWFuYWdlclxuICAgICAqIHRvIGVuc3VyZSB3ZSBhbHNvIGNyZWF0ZSBuZXcgc2NvcGVzIHBlciBjb250ZXh0LlxuICAgICAqL1xuICAgICB3aXRoKFxuICAgICAgY29udGV4dCxcbiAgICAgIGZuLFxuICAgICAgdGhpc0FyZyxcbiAgICAgIC4uLmFyZ3NcbiAgICApIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTY29wZXMgPSBnZXRTY29wZXNGcm9tQ29udGV4dChjb250ZXh0KTtcbiAgICAgIGNvbnN0IGN1cnJlbnRTY29wZSA9IGN1cnJlbnRTY29wZXM/LnNjb3BlIHx8IGNvcmUuZ2V0Q3VycmVudFNjb3BlKCk7XG4gICAgICBjb25zdCBjdXJyZW50SXNvbGF0aW9uU2NvcGUgPSBjdXJyZW50U2NvcGVzPy5pc29sYXRpb25TY29wZSB8fCBjb3JlLmdldElzb2xhdGlvblNjb3BlKCk7XG5cbiAgICAgIGNvbnN0IHNob3VsZEZvcmtJc29sYXRpb25TY29wZSA9IGNvbnRleHQuZ2V0VmFsdWUoU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZKSA9PT0gdHJ1ZTtcbiAgICAgIGNvbnN0IHNjb3BlID0gY29udGV4dC5nZXRWYWx1ZShTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVkpIDtcbiAgICAgIGNvbnN0IGlzb2xhdGlvblNjb3BlID0gY29udGV4dC5nZXRWYWx1ZShTRU5UUllfRk9SS19TRVRfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZKSA7XG5cbiAgICAgIGNvbnN0IG5ld0N1cnJlbnRTY29wZSA9IHNjb3BlIHx8IGN1cnJlbnRTY29wZS5jbG9uZSgpO1xuICAgICAgY29uc3QgbmV3SXNvbGF0aW9uU2NvcGUgPVxuICAgICAgICBpc29sYXRpb25TY29wZSB8fCAoc2hvdWxkRm9ya0lzb2xhdGlvblNjb3BlID8gY3VycmVudElzb2xhdGlvblNjb3BlLmNsb25lKCkgOiBjdXJyZW50SXNvbGF0aW9uU2NvcGUpO1xuICAgICAgY29uc3Qgc2NvcGVzID0geyBzY29wZTogbmV3Q3VycmVudFNjb3BlLCBpc29sYXRpb25TY29wZTogbmV3SXNvbGF0aW9uU2NvcGUgfTtcblxuICAgICAgY29uc3QgY3R4MSA9IHNldFNjb3Blc09uQ29udGV4dChjb250ZXh0LCBzY29wZXMpO1xuXG4gICAgICAvLyBSZW1vdmUgdGhlIHVubmVlZGVkIHZhbHVlcyBhZ2FpblxuICAgICAgY29uc3QgY3R4MiA9IGN0eDFcbiAgICAgICAgLmRlbGV0ZVZhbHVlKFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSlcbiAgICAgICAgLmRlbGV0ZVZhbHVlKFNFTlRSWV9GT1JLX1NFVF9TQ09QRV9DT05URVhUX0tFWSlcbiAgICAgICAgLmRlbGV0ZVZhbHVlKFNFTlRSWV9GT1JLX1NFVF9JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVkpO1xuXG4gICAgICBzZXRDb250ZXh0T25TY29wZShuZXdDdXJyZW50U2NvcGUsIGN0eDIpO1xuXG4gICAgICByZXR1cm4gc3VwZXIud2l0aChjdHgyLCBmbiwgdGhpc0FyZywgLi4uYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFNlbnRyeUNvbnRleHRNYW5hZ2VyIDtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHJ1bnMgdGhyb3VnaCBhIGxpc3Qgb2YgT1RFTCBTcGFucywgYW5kIHdyYXBzIHRoZW0gaW4gYW4gYFNwYW5Ob2RlYFxuICogd2hlcmUgZWFjaCBub2RlIGhvbGRzIGEgcmVmZXJlbmNlIHRvIHRoZWlyIHBhcmVudCBub2RlLlxuICovXG5mdW5jdGlvbiBncm91cFNwYW5zV2l0aFBhcmVudHMoc3BhbnMpIHtcbiAgY29uc3Qgbm9kZU1hcCA9IG5ldyBNYXAoKTtcblxuICBmb3IgKGNvbnN0IHNwYW4gb2Ygc3BhbnMpIHtcbiAgICBjcmVhdGVPclVwZGF0ZVNwYW5Ob2RlQW5kUmVmcyhub2RlTWFwLCBzcGFuKTtcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKG5vZGVNYXAsIGZ1bmN0aW9uIChbX2lkLCBzcGFuTm9kZV0pIHtcbiAgICByZXR1cm4gc3Bhbk5vZGU7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgcmV0dXJucyB0aGUgX2xvY2FsXyBwYXJlbnQgSUQgLSBgcGFyZW50SWRgIG9uIHRoZSBzcGFuIG1heSBwb2ludCB0byBhIHJlbW90ZSBzcGFuLlxuICovXG5mdW5jdGlvbiBnZXRMb2NhbFBhcmVudElkKHNwYW4pIHtcbiAgY29uc3QgcGFyZW50SXNSZW1vdGUgPSBzcGFuLmF0dHJpYnV0ZXNbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QQVJFTlRfSVNfUkVNT1RFXSA9PT0gdHJ1ZTtcbiAgLy8gSWYgdGhlIHBhcmVudElkIGlzIHRoZSB0cmFjZSBwYXJlbnQgSUQsIHdlIHByZXRlbmQgaXQncyB1bmRlZmluZWRcbiAgLy8gQXMgdGhpcyBtZWFucyB0aGUgcGFyZW50IGV4aXN0cyBzb21ld2hlcmUgZWxzZVxuICByZXR1cm4gIXBhcmVudElzUmVtb3RlID8gZ2V0UGFyZW50U3BhbklkKHNwYW4pIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPclVwZGF0ZVNwYW5Ob2RlQW5kUmVmcyhub2RlTWFwLCBzcGFuKSB7XG4gIGNvbnN0IGlkID0gc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZDtcbiAgY29uc3QgcGFyZW50SWQgPSBnZXRMb2NhbFBhcmVudElkKHNwYW4pO1xuXG4gIGlmICghcGFyZW50SWQpIHtcbiAgICBjcmVhdGVPclVwZGF0ZU5vZGUobm9kZU1hcCwgeyBpZCwgc3BhbiwgY2hpbGRyZW46IFtdIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVsc2UgbWFrZSBzdXJlIHRvIGNyZWF0ZSBwYXJlbnQgbm9kZSBhcyB3ZWxsXG4gIC8vIE5vdGUgdGhhdCB0aGUgcGFyZW50IG1heSBub3Qga25vdyBpdCdzIHBhcmVudCBfeWV0XywgdGhpcyBtYXkgYmUgdXBkYXRlZCBpbiBhIGxhdGVyIHBhc3NcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGNyZWF0ZU9yR2V0UGFyZW50Tm9kZShub2RlTWFwLCBwYXJlbnRJZCk7XG4gIGNvbnN0IG5vZGUgPSBjcmVhdGVPclVwZGF0ZU5vZGUobm9kZU1hcCwgeyBpZCwgc3BhbiwgcGFyZW50Tm9kZSwgY2hpbGRyZW46IFtdIH0pO1xuICBwYXJlbnROb2RlLmNoaWxkcmVuLnB1c2gobm9kZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9yR2V0UGFyZW50Tm9kZShub2RlTWFwLCBpZCkge1xuICBjb25zdCBleGlzdGluZyA9IG5vZGVNYXAuZ2V0KGlkKTtcblxuICBpZiAoZXhpc3RpbmcpIHtcbiAgICByZXR1cm4gZXhpc3Rpbmc7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlT3JVcGRhdGVOb2RlKG5vZGVNYXAsIHsgaWQsIGNoaWxkcmVuOiBbXSB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVOb2RlKG5vZGVNYXAsIHNwYW5Ob2RlKSB7XG4gIGNvbnN0IGV4aXN0aW5nID0gbm9kZU1hcC5nZXQoc3Bhbk5vZGUuaWQpO1xuXG4gIC8vIElmIHNwYW4gaXMgYWxyZWFkeSBzZXQsIG5vdGhpbmcgdG8gZG8gaGVyZVxuICBpZiAoZXhpc3Rpbmc/LnNwYW4pIHtcbiAgICByZXR1cm4gZXhpc3Rpbmc7XG4gIH1cblxuICAvLyBJZiBpdCBleGlzdHMgYnV0IHNwYW4gaXMgbm90IHNldCB5ZXQsIHdlIHVwZGF0ZSBpdFxuICBpZiAoZXhpc3RpbmcgJiYgIWV4aXN0aW5nLnNwYW4pIHtcbiAgICBleGlzdGluZy5zcGFuID0gc3Bhbk5vZGUuc3BhbjtcbiAgICBleGlzdGluZy5wYXJlbnROb2RlID0gc3Bhbk5vZGUucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gZXhpc3Rpbmc7XG4gIH1cblxuICAvLyBFbHNlLCB3ZSBjcmVhdGUgYSBuZXcgb25lLi4uXG4gIG5vZGVNYXAuc2V0KHNwYW5Ob2RlLmlkLCBzcGFuTm9kZSk7XG4gIHJldHVybiBzcGFuTm9kZTtcbn1cblxuLy8gY2Fub25pY2FsQ29kZXNHcnBjTWFwIG1hcHMgc29tZSBHUlBDIGNvZGVzIHRvIFNlbnRyeSdzIHNwYW4gc3RhdHVzZXMuIFNlZSBkZXNjcmlwdGlvbiBpbiBncnBjIGRvY3VtZW50YXRpb24uXG5jb25zdCBjYW5vbmljYWxHcnBjRXJyb3JDb2Rlc01hcCA9IHtcbiAgJzEnOiAnY2FuY2VsbGVkJyxcbiAgJzInOiAndW5rbm93bl9lcnJvcicsXG4gICczJzogJ2ludmFsaWRfYXJndW1lbnQnLFxuICAnNCc6ICdkZWFkbGluZV9leGNlZWRlZCcsXG4gICc1JzogJ25vdF9mb3VuZCcsXG4gICc2JzogJ2FscmVhZHlfZXhpc3RzJyxcbiAgJzcnOiAncGVybWlzc2lvbl9kZW5pZWQnLFxuICAnOCc6ICdyZXNvdXJjZV9leGhhdXN0ZWQnLFxuICAnOSc6ICdmYWlsZWRfcHJlY29uZGl0aW9uJyxcbiAgJzEwJzogJ2Fib3J0ZWQnLFxuICAnMTEnOiAnb3V0X29mX3JhbmdlJyxcbiAgJzEyJzogJ3VuaW1wbGVtZW50ZWQnLFxuICAnMTMnOiAnaW50ZXJuYWxfZXJyb3InLFxuICAnMTQnOiAndW5hdmFpbGFibGUnLFxuICAnMTUnOiAnZGF0YV9sb3NzJyxcbiAgJzE2JzogJ3VuYXV0aGVudGljYXRlZCcsXG59IDtcblxuY29uc3QgaXNTdGF0dXNFcnJvck1lc3NhZ2VWYWxpZCA9IChtZXNzYWdlKSA9PiB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGNhbm9uaWNhbEdycGNFcnJvckNvZGVzTWFwKS5pbmNsdWRlcyhtZXNzYWdlICk7XG59O1xuXG4vKipcbiAqIEdldCBhIFNlbnRyeSBzcGFuIHN0YXR1cyBmcm9tIGFuIG90ZWwgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gbWFwU3RhdHVzKHNwYW4pIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHNwYW5IYXNBdHRyaWJ1dGVzKHNwYW4pID8gc3Bhbi5hdHRyaWJ1dGVzIDoge307XG4gIGNvbnN0IHN0YXR1cyA9IHNwYW5IYXNTdGF0dXMoc3BhbikgPyBzcGFuLnN0YXR1cyA6IHVuZGVmaW5lZDtcblxuICBpZiAoc3RhdHVzKSB7XG4gICAgLy8gU2luY2Ugc3BhbiBzdGF0dXMgT0sgaXMgbm90IHNldCBieSBkZWZhdWx0LCB3ZSBnaXZlIGl0IHByaW9yaXR5OiBodHRwczovL29wZW50ZWxlbWV0cnkuaW8vZG9jcy9jb25jZXB0cy9zaWduYWxzL3RyYWNlcy8jc3Bhbi1zdGF0dXNcbiAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGFwaS5TcGFuU3RhdHVzQ29kZS5PSykge1xuICAgICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19PSyB9O1xuICAgICAgLy8gSWYgdGhlIHNwYW4gaXMgYWxyZWFkeSBtYXJrZWQgYXMgZXJyb25lb3VzIHdlIHJldHVybiB0aGF0IGV4YWN0IHN0YXR1c1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzLmNvZGUgPT09IGFwaS5TcGFuU3RhdHVzQ29kZS5FUlJPUikge1xuICAgICAgaWYgKHR5cGVvZiBzdGF0dXMubWVzc2FnZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgaW5mZXJyZWRTdGF0dXMgPSBpbmZlclN0YXR1c0Zyb21BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAoaW5mZXJyZWRTdGF0dXMpIHtcbiAgICAgICAgICByZXR1cm4gaW5mZXJyZWRTdGF0dXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXR1cy5tZXNzYWdlICYmIGlzU3RhdHVzRXJyb3JNZXNzYWdlVmFsaWQoc3RhdHVzLm1lc3NhZ2UpKSB7XG4gICAgICAgIHJldHVybiB7IGNvZGU6IGNvcmUuU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6IHN0YXR1cy5tZXNzYWdlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBjb2RlOiBjb3JlLlNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAndW5rbm93bl9lcnJvcicgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgc3BhbiBzdGF0dXMgaXMgVU5TRVQsIHdlIHRyeSB0byBpbmZlciBpdCBmcm9tIEhUVFAgb3IgR1JQQyBzdGF0dXMgY29kZXMuXG4gIGNvbnN0IGluZmVycmVkU3RhdHVzID0gaW5mZXJTdGF0dXNGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcblxuICBpZiAoaW5mZXJyZWRTdGF0dXMpIHtcbiAgICByZXR1cm4gaW5mZXJyZWRTdGF0dXM7XG4gIH1cblxuICAvLyBXZSBkZWZhdWx0IHRvIHNldHRpbmcgdGhlIHNwYW5zIHN0YXR1cyB0byBvay5cbiAgaWYgKHN0YXR1cz8uY29kZSA9PT0gYXBpLlNwYW5TdGF0dXNDb2RlLlVOU0VUKSB7XG4gICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19PSyB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGNvZGU6IGNvcmUuU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICd1bmtub3duX2Vycm9yJyB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZmVyU3RhdHVzRnJvbUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAvLyBJZiB0aGUgc3BhbiBzdGF0dXMgaXMgVU5TRVQsIHdlIHRyeSB0byBpbmZlciBpdCBmcm9tIEhUVFAgb3IgR1JQQyBzdGF0dXMgY29kZXMuXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IGh0dHBDb2RlQXR0cmlidXRlID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLkFUVFJfSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERV0gfHwgYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgZ3JwY0NvZGVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfUlBDX0dSUENfU1RBVFVTX0NPREVdO1xuXG4gIGNvbnN0IG51bWJlckh0dHBDb2RlID1cbiAgICB0eXBlb2YgaHR0cENvZGVBdHRyaWJ1dGUgPT09ICdudW1iZXInXG4gICAgICA/IGh0dHBDb2RlQXR0cmlidXRlXG4gICAgICA6IHR5cGVvZiBodHRwQ29kZUF0dHJpYnV0ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBwYXJzZUludChodHRwQ29kZUF0dHJpYnV0ZSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKHR5cGVvZiBudW1iZXJIdHRwQ29kZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gY29yZS5nZXRTcGFuU3RhdHVzRnJvbUh0dHBDb2RlKG51bWJlckh0dHBDb2RlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ3JwY0NvZGVBdHRyaWJ1dGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogY2Fub25pY2FsR3JwY0Vycm9yQ29kZXNNYXBbZ3JwY0NvZGVBdHRyaWJ1dGVdIHx8ICd1bmtub3duX2Vycm9yJyB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuY29uc3QgTUFYX1NQQU5fQ09VTlQgPSAxMDAwO1xuY29uc3QgREVGQVVMVF9USU1FT1VUID0gMzAwOyAvLyA1IG1pblxuXG4vKipcbiAqIEEgU2VudHJ5LXNwZWNpZmljIGV4cG9ydGVyIHRoYXQgY29udmVydHMgT3BlblRlbGVtZXRyeSBTcGFucyB0byBTZW50cnkgU3BhbnMgJiBUcmFuc2FjdGlvbnMuXG4gKi9cbmNsYXNzIFNlbnRyeVNwYW5FeHBvcnRlciB7XG4gIC8qXG4gICAqIEEgcXVpY2sgZXhwbGFuYXRpb24gb24gdGhlIGJ1Y2tldHM6IFdlIGRvIGJ1Y2tldGluZyBvZiBmaW5pc2hlZCBzcGFucyBmb3IgZWZmaWNpZW5jeS4gVGhpcyBzcGFuIGV4cG9ydGVyIGlzXG4gICAqIGFjY3VtdWxhdGluZyBzcGFucyB1bnRpbCBhIHJvb3Qgc3BhbiBpcyBlbmNvdW50ZXJlZCBhbmQgdGhlbiBpdCBmbHVzaGVzIGFsbCB0aGUgc3BhbnMgdGhhdCBhcmUgZGVzY2VuZGFudHMgb2YgdGhhdFxuICAgKiByb290IHNwYW4uIEJlY2F1c2UgaXQgaXMgdG90YWxseSBpbiB0aGUgcmVhbG0gb2YgcG9zc2liaWxpdGllcyB0aGF0IHJvb3Qgc3BhbnMgYXJlIG5ldmVyIGZpbmlzaGVkLCBhbmQgd2UgZG9uJ3RcbiAgICogd2FudCB0byBhY2N1bXVsYXRlIHNwYW5zIGluZGVmaW5pdGVseSBpbiBtZW1vcnksIHdlIG5lZWQgdG8gcGVyaW9kaWNhbGx5IGV2YWN1YXRlIHNwYW5zLiBOYWl2ZWx5IHdlIGNvdWxkIHNpbXBseVxuICAgKiBzdG9yZSB0aGUgc3BhbnMgaW4gYW4gYXJyYXkgYW5kIGVhY2ggdGltZSBhIG5ldyBzcGFuIGNvbWVzIGluIHdlIGNvdWxkIGl0ZXJhdGUgdGhyb3VnaCB0aGUgZW50aXJlIGFycmF5IGFuZFxuICAgKiBldmFjdWF0ZSBhbGwgc3BhbnMgdGhhdCBoYXZlIGFuIGVuZC10aW1lc3RhbXAgdGhhdCBpcyBvbGRlciB0aGFuIG91ciBsaW1pdC4gVGhpcyBjb3VsZCBnZXQgcXVpdGUgZXhwZW5zaXZlIGJlY2F1c2VcbiAgICogd2Ugd291bGQgaGF2ZSB0byBpdGVyYXRlIGEgcG90ZW50aWFsbHkgbGFyZ2UgbnVtYmVyIG9mIHNwYW5zIGV2ZXJ5IHRpbWUgd2UgZXZhY3VhdGUuIFdlIHdhbnQgdG8gYXZvaWQgdGhlc2UgbGFyZ2VcbiAgICogYnVyc3RzIG9mIGNvbXB1dGF0aW9uLlxuICAgKlxuICAgKiBJbnN0ZWFkIHdlIGdvIGZvciBhIGJ1Y2tldGluZyBhcHByb2FjaCBhbmQgcHV0IHNwYW5zIGludG8gYnVja2V0cywgYmFzZWQgb24gd2hhdCBzZWNvbmRcbiAgICogKG1vZHVsbyB0aGUgdGltZSBsaW1pdCkgdGhlIHNwYW4gd2FzIHB1dCBpbnRvIHRoZSBleHBvcnRlci4gV2l0aCBidWNrZXRzLCB3aGVuIHdlIGRlY2lkZSB0byBldmFjdWF0ZSwgd2UgY2FuXG4gICAqIGl0ZXJhdGUgdGhyb3VnaCB0aGUgYnVja2V0IGVudHJpZXMgaW5zdGVhZCwgd2hpY2ggaGF2ZSBhbiB1cHBlciBib3VuZCBvZiBpdGVtcywgbWFraW5nIHRoZSBldmFjdWF0aW9uIG11Y2ggbW9yZVxuICAgKiBlZmZpY2llbnQuIENsZWFuaW5nIHVwIGFsc28gYmVjb21lcyBtdWNoIG1vcmUgZWZmaWNpZW50IHNpbmNlIGl0IHNpbXBseSBpbnZvbHZlcyBkZS1yZWZlcmVuY2luZyBhIGJ1Y2tldCB3aXRoaW4gdGhlXG4gICAqIGJ1Y2tldCBhcnJheSwgYW5kIGxldHRpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uIHRha2UgY2FyZSBvZiB0aGUgcmVzdC5cbiAgICovXG5cbiAgLy8gRXNzZW50aWFsbHkgYSBhIHNldCBvZiBzcGFuIGlkcyB0aGF0IGFyZSBhbHJlYWR5IHNlbnQuIFRoZSB2YWx1ZXMgYXJlIGV4cGlyYXRpb25cbiAgLy8gdGltZXMgaW4gdGhpcyBjYWNoZSBzbyB3ZSBkb24ndCBob2xkIG9udG8gdGhlbSBpbmRlZmluaXRlbHkuXG5cbiAgLyogSW50ZXJuYWxseSwgd2UgdXNlIGEgZGVib3VuY2VkIGZsdXNoIHRvIGdpdmUgc29tZSB3aWdnbGUgcm9vbSB0byB0aGUgc3BhbiBwcm9jZXNzb3IgdG8gYWNjdW11bGF0ZSBtb3JlIHNwYW5zLiAqL1xuXG4gICBjb25zdHJ1Y3RvcihvcHRpb25zXG5cbikge1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldFNpemUgPSBvcHRpb25zPy50aW1lb3V0IHx8IERFRkFVTFRfVElNRU9VVDtcbiAgICB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRzID0gbmV3IEFycmF5KHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldFNpemUpLmZpbGwodW5kZWZpbmVkKTtcbiAgICB0aGlzLl9sYXN0Q2xlYW51cFRpbWVzdGFtcEluUyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIHRoaXMuX3NwYW5zVG9CdWNrZXRFbnRyeSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5fc2VudFNwYW5zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2RlYm91bmNlZEZsdXNoID0gY29yZS5kZWJvdW5jZSh0aGlzLmZsdXNoLmJpbmQodGhpcyksIDEsIHsgbWF4V2FpdDogMTAwIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydCBhIHNpbmdsZSBzcGFuLlxuICAgKiBUaGlzIGlzIGNhbGxlZCBieSB0aGUgc3BhbiBwcm9jZXNzb3Igd2hlbmV2ZXIgYSBzcGFuIGlzIGVuZGVkLlxuICAgKi9cbiAgIGV4cG9ydChzcGFuKSB7XG4gICAgY29uc3QgY3VycmVudFRpbWVzdGFtcEluUyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuXG4gICAgaWYgKHRoaXMuX2xhc3RDbGVhbnVwVGltZXN0YW1wSW5TICE9PSBjdXJyZW50VGltZXN0YW1wSW5TKSB7XG4gICAgICBsZXQgZHJvcHBlZFNwYW5Db3VudCA9IDA7XG4gICAgICB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRzLmZvckVhY2goKGJ1Y2tldCwgaSkgPT4ge1xuICAgICAgICBpZiAoYnVja2V0ICYmIGJ1Y2tldC50aW1lc3RhbXBJblMgPD0gY3VycmVudFRpbWVzdGFtcEluUyAtIHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldFNpemUpIHtcbiAgICAgICAgICBkcm9wcGVkU3BhbkNvdW50ICs9IGJ1Y2tldC5zcGFucy5zaXplO1xuICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldHNbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGRyb3BwZWRTcGFuQ291bnQgPiAwKSB7XG4gICAgICAgIERFQlVHX0JVSUxEICYmXG4gICAgICAgICAgY29yZS5kZWJ1Zy5sb2coXG4gICAgICAgICAgICBgU3BhbkV4cG9ydGVyIGRyb3BwZWQgJHtkcm9wcGVkU3BhbkNvdW50fSBzcGFucyBiZWNhdXNlIHRoZXkgd2VyZSBwZW5kaW5nIGZvciBtb3JlIHRoYW4gJHt0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRTaXplfSBzZWNvbmRzLmAsXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xhc3RDbGVhbnVwVGltZXN0YW1wSW5TID0gY3VycmVudFRpbWVzdGFtcEluUztcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50QnVja2V0SW5kZXggPSBjdXJyZW50VGltZXN0YW1wSW5TICUgdGhpcy5fZmluaXNoZWRTcGFuQnVja2V0U2l6ZTtcbiAgICBjb25zdCBjdXJyZW50QnVja2V0ID0gdGhpcy5fZmluaXNoZWRTcGFuQnVja2V0c1tjdXJyZW50QnVja2V0SW5kZXhdIHx8IHtcbiAgICAgIHRpbWVzdGFtcEluUzogY3VycmVudFRpbWVzdGFtcEluUyxcbiAgICAgIHNwYW5zOiBuZXcgU2V0KCksXG4gICAgfTtcbiAgICB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRzW2N1cnJlbnRCdWNrZXRJbmRleF0gPSBjdXJyZW50QnVja2V0O1xuICAgIGN1cnJlbnRCdWNrZXQuc3BhbnMuYWRkKHNwYW4pO1xuICAgIHRoaXMuX3NwYW5zVG9CdWNrZXRFbnRyeS5zZXQoc3BhbiwgY3VycmVudEJ1Y2tldCk7XG5cbiAgICAvLyBJZiB0aGUgc3BhbiBkb2Vzbid0IGhhdmUgYSBsb2NhbCBwYXJlbnQgSUQgKGl0J3MgYSByb290IHNwYW4pLCB3ZSdyZSBnb25uYSBmbHVzaCBhbGwgdGhlIGVuZGVkIHNwYW5zXG4gICAgY29uc3QgbG9jYWxQYXJlbnRJZCA9IGdldExvY2FsUGFyZW50SWQoc3Bhbik7XG4gICAgaWYgKCFsb2NhbFBhcmVudElkIHx8IHRoaXMuX3NlbnRTcGFucy5oYXMobG9jYWxQYXJlbnRJZCkpIHtcbiAgICAgIHRoaXMuX2RlYm91bmNlZEZsdXNoKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyeSB0byBmbHVzaCBhbnkgcGVuZGluZyBzcGFucyBpbW1lZGlhdGVseS5cbiAgICogVGhpcyBpcyBjYWxsZWQgaW50ZXJuYWxseSBieSB0aGUgZXhwb3J0ZXIgKHZpYSBfZGVib3VuY2VkRmx1c2gpLFxuICAgKiBidXQgY2FuIGFsc28gYmUgdHJpZ2dlcmVkIGV4dGVybmFsbHkgaWYgd2UgZm9yY2UtZmx1c2guXG4gICAqL1xuICAgZmx1c2goKSB7XG4gICAgY29uc3QgZmluaXNoZWRTcGFucyA9IHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldHMuZmxhdE1hcChidWNrZXQgPT4gKGJ1Y2tldCA/IEFycmF5LmZyb20oYnVja2V0LnNwYW5zKSA6IFtdKSk7XG5cbiAgICB0aGlzLl9mbHVzaFNlbnRTcGFuQ2FjaGUoKTtcbiAgICBjb25zdCBzZW50U3BhbnMgPSB0aGlzLl9tYXliZVNlbmQoZmluaXNoZWRTcGFucyk7XG5cbiAgICBjb25zdCBzZW50U3BhbkNvdW50ID0gc2VudFNwYW5zLnNpemU7XG4gICAgY29uc3QgcmVtYWluaW5nT3BlblNwYW5Db3VudCA9IGZpbmlzaGVkU3BhbnMubGVuZ3RoIC0gc2VudFNwYW5Db3VudDtcbiAgICBERUJVR19CVUlMRCAmJlxuICAgICAgY29yZS5kZWJ1Zy5sb2coXG4gICAgICAgIGBTcGFuRXhwb3J0ZXIgZXhwb3J0ZWQgJHtzZW50U3BhbkNvdW50fSBzcGFucywgJHtyZW1haW5pbmdPcGVuU3BhbkNvdW50fSBzcGFucyBhcmUgd2FpdGluZyBmb3IgdGhlaXIgcGFyZW50IHNwYW5zIHRvIGZpbmlzaGAsXG4gICAgICApO1xuXG4gICAgY29uc3QgZXhwaXJhdGlvbkRhdGUgPSBEYXRlLm5vdygpICsgREVGQVVMVF9USU1FT1VUICogMTAwMDtcblxuICAgIGZvciAoY29uc3Qgc3BhbiBvZiBzZW50U3BhbnMpIHtcbiAgICAgIHRoaXMuX3NlbnRTcGFucy5zZXQoc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZCwgZXhwaXJhdGlvbkRhdGUpO1xuICAgICAgY29uc3QgYnVja2V0RW50cnkgPSB0aGlzLl9zcGFuc1RvQnVja2V0RW50cnkuZ2V0KHNwYW4pO1xuICAgICAgaWYgKGJ1Y2tldEVudHJ5KSB7XG4gICAgICAgIGJ1Y2tldEVudHJ5LnNwYW5zLmRlbGV0ZShzcGFuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FuY2VsIGEgcGVuZGluZyBkZWJvdW5jZWQgZmx1c2gsIGlmIHRoZXJlIGlzIG9uZVxuICAgIC8vIFRoaXMgY2FuIGJlIHJlbGV2YW50IGlmIHdlIGRpcmVjdGx5IGZsdXNoLCBjaXJjdW12ZW50aW5nIHRoZSBkZWJvdW5jZVxuICAgIC8vIGluIHRoYXQgY2FzZSwgd2Ugd2FudCB0byBjYW5jZWwgYW55IHBlbmRpbmcgZGVib3VuY2VkIGZsdXNoXG4gICAgdGhpcy5fZGVib3VuY2VkRmx1c2guY2FuY2VsKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgdGhlIGV4cG9ydGVyLlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBzcGFuIHByb2Nlc3NvciBpcyBzaHV0IGRvd24uXG4gICAqL1xuICAgY2xlYXIoKSB7XG4gICAgdGhpcy5fZmluaXNoZWRTcGFuQnVja2V0cyA9IHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldHMuZmlsbCh1bmRlZmluZWQpO1xuICAgIHRoaXMuX3NlbnRTcGFucy5jbGVhcigpO1xuICAgIHRoaXMuX2RlYm91bmNlZEZsdXNoLmNhbmNlbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgdGhlIGdpdmVuIHNwYW5zLCBidXQgb25seSBpZiB0aGV5IGFyZSBwYXJ0IG9mIGEgZmluaXNoZWQgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFJldHVybnMgdGhlIHNlbnQgc3BhbnMuXG4gICAqIFNwYW5zIHJlbWFpbiB1bnNlbnQgd2hlbiB0aGVpciBwYXJlbnQgc3BhbiBpcyBub3QgeWV0IGZpbmlzaGVkLlxuICAgKiBUaGlzIHdpbGwgaGFwcGVuIHJlZ3VsYXJseSwgYXMgY2hpbGQgc3BhbnMgYXJlIGdlbmVyYWxseSBmaW5pc2hlZCBiZWZvcmUgdGhlaXIgcGFyZW50cy5cbiAgICogQnV0IGl0IF9jb3VsZF8gYWxzbyBoYXBwZW4gYmVjYXVzZSwgZm9yIHdoYXRldmVyIHJlYXNvbiwgYSBwYXJlbnQgc3BhbiB3YXMgbG9zdC5cbiAgICogSW4gdGhpcyBjYXNlLCB3ZSdsbCBldmVudHVhbGx5IG5lZWQgdG8gY2xlYW4gdGhpcyB1cC5cbiAgICovXG4gICBfbWF5YmVTZW5kKHNwYW5zKSB7XG4gICAgY29uc3QgZ3JvdXBlZCA9IGdyb3VwU3BhbnNXaXRoUGFyZW50cyhzcGFucyk7XG4gICAgY29uc3Qgc2VudFNwYW5zID0gbmV3IFNldCgpO1xuXG4gICAgY29uc3Qgcm9vdE5vZGVzID0gdGhpcy5fZ2V0Q29tcGxldGVkUm9vdE5vZGVzKGdyb3VwZWQpO1xuXG4gICAgZm9yIChjb25zdCByb290IG9mIHJvb3ROb2Rlcykge1xuICAgICAgY29uc3Qgc3BhbiA9IHJvb3Quc3BhbjtcbiAgICAgIHNlbnRTcGFucy5hZGQoc3Bhbik7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkV2ZW50ID0gY3JlYXRlVHJhbnNhY3Rpb25Gb3JPdGVsU3BhbihzcGFuKTtcblxuICAgICAgLy8gQWRkIGFuIGF0dHJpYnV0ZSB0byB0aGUgdHJhbnNhY3Rpb24gZXZlbnQgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIGlzIGFuIG9ycGhhbmVkIHRyYW5zYWN0aW9uXG4gICAgICBpZiAocm9vdC5wYXJlbnROb2RlICYmIHRoaXMuX3NlbnRTcGFucy5oYXMocm9vdC5wYXJlbnROb2RlLmlkKSkge1xuICAgICAgICBjb25zdCB0cmFjZURhdGEgPSB0cmFuc2FjdGlvbkV2ZW50LmNvbnRleHRzPy50cmFjZT8uZGF0YTtcbiAgICAgICAgaWYgKHRyYWNlRGF0YSkge1xuICAgICAgICAgIHRyYWNlRGF0YVsnc2VudHJ5LnBhcmVudF9zcGFuX2FscmVhZHlfc2VudCddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBXZSdsbCByZWN1cnNpdmVseSBhZGQgYWxsIHRoZSBjaGlsZCBzcGFucyB0byB0aGlzIGFycmF5XG4gICAgICBjb25zdCBzcGFucyA9IHRyYW5zYWN0aW9uRXZlbnQuc3BhbnMgfHwgW107XG5cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygcm9vdC5jaGlsZHJlbikge1xuICAgICAgICBjcmVhdGVBbmRGaW5pc2hTcGFuRm9yT3RlbFNwYW4oY2hpbGQsIHNwYW5zLCBzZW50U3BhbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBzcGFucy5zb3J0KCkgbXV0YXRlcyB0aGUgYXJyYXksIGJ1dCB3ZSBkbyBub3QgdXNlIHRoaXMgYW55bW9yZSBhZnRlciB0aGlzIHBvaW50XG4gICAgICAvLyBzbyB3ZSBjYW4gc2FmZWx5IG11dGF0ZSBpdCBoZXJlXG4gICAgICB0cmFuc2FjdGlvbkV2ZW50LnNwYW5zID1cbiAgICAgICAgc3BhbnMubGVuZ3RoID4gTUFYX1NQQU5fQ09VTlRcbiAgICAgICAgICA/IHNwYW5zLnNvcnQoKGEsIGIpID0+IGEuc3RhcnRfdGltZXN0YW1wIC0gYi5zdGFydF90aW1lc3RhbXApLnNsaWNlKDAsIE1BWF9TUEFOX0NPVU5UKVxuICAgICAgICAgIDogc3BhbnM7XG5cbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50cyA9IGNvcmUudGltZWRFdmVudHNUb01lYXN1cmVtZW50cyhzcGFuLmV2ZW50cyk7XG4gICAgICBpZiAobWVhc3VyZW1lbnRzKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uRXZlbnQubWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzO1xuICAgICAgfVxuXG4gICAgICBjb3JlLmNhcHR1cmVFdmVudCh0cmFuc2FjdGlvbkV2ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VudFNwYW5zO1xuICB9XG5cbiAgLyoqIFJlbW92ZSBcImV4cGlyZWRcIiBzcGFuIGlkIGVudHJpZXMgZnJvbSB0aGUgX3NlbnRTcGFucyBjYWNoZS4gKi9cbiAgIF9mbHVzaFNlbnRTcGFuQ2FjaGUoKSB7XG4gICAgY29uc3QgY3VycmVudFRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgLy8gTm90ZSwgaXQgaXMgc2FmZSB0byBkZWxldGUgaXRlbXMgZnJvbSB0aGUgbWFwIGFzIHdlIGdvOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzU5NDM5OTUvOTAyOTdcbiAgICBmb3IgKGNvbnN0IFtzcGFuSWQsIGV4cGlyYXRpb25UaW1lXSBvZiB0aGlzLl9zZW50U3BhbnMuZW50cmllcygpKSB7XG4gICAgICBpZiAoZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWVzdGFtcCkge1xuICAgICAgICB0aGlzLl9zZW50U3BhbnMuZGVsZXRlKHNwYW5JZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIENoZWNrIGlmIGEgbm9kZSBpcyBhIGNvbXBsZXRlZCByb290IG5vZGUgb3IgYSBub2RlIHdob3NlIHBhcmVudCBoYXMgYWxyZWFkeSBiZWVuIHNlbnQgKi9cbiAgIF9ub2RlSXNDb21wbGV0ZWRSb290Tm9kZU9ySGFzU2VudFBhcmVudChub2RlKSB7XG4gICAgcmV0dXJuICEhbm9kZS5zcGFuICYmICghbm9kZS5wYXJlbnROb2RlIHx8IHRoaXMuX3NlbnRTcGFucy5oYXMobm9kZS5wYXJlbnROb2RlLmlkKSk7XG4gIH1cblxuICAvKiogR2V0IGFsbCBjb21wbGV0ZWQgcm9vdCBub2RlcyBmcm9tIGEgbGlzdCBvZiBub2RlcyAqL1xuICAgX2dldENvbXBsZXRlZFJvb3ROb2Rlcyhub2Rlcykge1xuICAgIC8vIFRPRE86IFdlIHNob3VsZCBiZSBhYmxlIHRvIHJlbW92ZSB0aGUgZXhwbGljaXQgYG5vZGUgaXMgU3Bhbk5vZGVDb21wbGV0ZWRgIHR5cGUgZ3VhcmRcbiAgICAvLyAgICAgICBvbmNlIHdlIHN0b3Agc3VwcG9ydGluZyBUUyA8IDUuNVxuICAgIHJldHVybiBub2Rlcy5maWx0ZXIoKG5vZGUpID0+IHRoaXMuX25vZGVJc0NvbXBsZXRlZFJvb3ROb2RlT3JIYXNTZW50UGFyZW50KG5vZGUpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVNwYW4oc3Bhbikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc3Bhbi5hdHRyaWJ1dGVzO1xuXG4gIGNvbnN0IG9yaWdpbiA9IGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl0gO1xuICBjb25zdCBvcCA9IGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXSA7XG4gIGNvbnN0IHNvdXJjZSA9IGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV0gO1xuXG4gIHJldHVybiB7IG9yaWdpbiwgb3AsIHNvdXJjZSB9O1xufVxuXG4vKiogRXhwb3J0ZWQgb25seSBmb3IgdGVzdHMuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvbkZvck90ZWxTcGFuKHNwYW4pIHtcbiAgY29uc3QgeyBvcCwgZGVzY3JpcHRpb24sIGRhdGEsIG9yaWdpbiA9ICdtYW51YWwnLCBzb3VyY2UgfSA9IGdldFNwYW5EYXRhKHNwYW4pO1xuICBjb25zdCBjYXB0dXJlZFNwYW5TY29wZXMgPSBjb3JlLmdldENhcHR1cmVkU2NvcGVzT25TcGFuKHNwYW4gKTtcblxuICBjb25zdCBzYW1wbGVSYXRlID0gc3Bhbi5hdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURV0gO1xuXG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdOiBzb3VyY2UsXG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURV06IHNhbXBsZVJhdGUsXG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF06IG9wLFxuICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXTogb3JpZ2luLFxuICAgIC4uLmRhdGEsXG4gICAgLi4ucmVtb3ZlU2VudHJ5QXR0cmlidXRlcyhzcGFuLmF0dHJpYnV0ZXMpLFxuICB9O1xuXG4gIGNvbnN0IHsgbGlua3MgfSA9IHNwYW47XG4gIGNvbnN0IHsgdHJhY2VJZDogdHJhY2VfaWQsIHNwYW5JZDogc3Bhbl9pZCB9ID0gc3Bhbi5zcGFuQ29udGV4dCgpO1xuXG4gIC8vIElmIHBhcmVudFNwYW5JZEZyb21UcmFjZVN0YXRlIGlzIGRlZmluZWQgYXQgYWxsLCB3ZSB3YW50IGl0IHRvIHRha2UgcHJlY2VkZW5jZVxuICAvLyBJbiB0aGF0IGNhc2UsIGFuIGVtcHR5IHN0cmluZyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgXCJubyBwYXJlbnQgc3BhbiBpZFwiLFxuICAvLyBldmVuIGlmIGBzcGFuLnBhcmVudFNwYW5JZGAgaXMgc2V0XG4gIC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2hlbiB3ZSBhcmUgc3RhcnRpbmcgYSBuZXcgdHJhY2UsIHdoZXJlIHdlIGhhdmUgYSB2aXJ0dWFsIHNwYW4gYmFzZWQgb24gdGhlIHByb3BhZ2F0aW9uQ29udGV4dFxuICAvLyBXZSBvbmx5IHdhbnQgdG8gY29udGludWUgdGhlIHRyYWNlSWQgaW4gdGhpcyBjYXNlLCBidXQgaWdub3JlIHRoZSBwYXJlbnQgc3BhblxuICBjb25zdCBwYXJlbnRfc3Bhbl9pZCA9IGdldFBhcmVudFNwYW5JZChzcGFuKTtcblxuICBjb25zdCBzdGF0dXMgPSBtYXBTdGF0dXMoc3Bhbik7XG5cbiAgY29uc3QgdHJhY2VDb250ZXh0ID0ge1xuICAgIHBhcmVudF9zcGFuX2lkLFxuICAgIHNwYW5faWQsXG4gICAgdHJhY2VfaWQsXG4gICAgZGF0YTogYXR0cmlidXRlcyxcbiAgICBvcmlnaW4sXG4gICAgb3AsXG4gICAgc3RhdHVzOiBjb3JlLmdldFN0YXR1c01lc3NhZ2Uoc3RhdHVzKSwgLy8gQXMgcGVyIHByb3RvY29sLCBzcGFuIHN0YXR1cyBpcyBhbGxvd2VkIHRvIGJlIHVuZGVmaW5lZFxuICAgIGxpbmtzOiBjb3JlLmNvbnZlcnRTcGFuTGlua3NGb3JFbnZlbG9wZShsaW5rcyksXG4gIH07XG5cbiAgY29uc3Qgc3RhdHVzQ29kZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdO1xuICBjb25zdCByZXNwb25zZUNvbnRleHQgPSB0eXBlb2Ygc3RhdHVzQ29kZSA9PT0gJ251bWJlcicgPyB7IHJlc3BvbnNlOiB7IHN0YXR1c19jb2RlOiBzdGF0dXNDb2RlIH0gfSA6IHVuZGVmaW5lZDtcblxuICBjb25zdCB0cmFuc2FjdGlvbkV2ZW50ID0ge1xuICAgIGNvbnRleHRzOiB7XG4gICAgICB0cmFjZTogdHJhY2VDb250ZXh0LFxuICAgICAgb3RlbDoge1xuICAgICAgICByZXNvdXJjZTogc3Bhbi5yZXNvdXJjZS5hdHRyaWJ1dGVzLFxuICAgICAgfSxcbiAgICAgIC4uLnJlc3BvbnNlQ29udGV4dCxcbiAgICB9LFxuICAgIHNwYW5zOiBbXSxcbiAgICBzdGFydF90aW1lc3RhbXA6IGNvcmUuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhzcGFuLnN0YXJ0VGltZSksXG4gICAgdGltZXN0YW1wOiBjb3JlLnNwYW5UaW1lSW5wdXRUb1NlY29uZHMoc3Bhbi5lbmRUaW1lKSxcbiAgICB0cmFuc2FjdGlvbjogZGVzY3JpcHRpb24sXG4gICAgdHlwZTogJ3RyYW5zYWN0aW9uJyxcbiAgICBzZGtQcm9jZXNzaW5nTWV0YWRhdGE6IHtcbiAgICAgIGNhcHR1cmVkU3BhblNjb3BlOiBjYXB0dXJlZFNwYW5TY29wZXMuc2NvcGUsXG4gICAgICBjYXB0dXJlZFNwYW5Jc29sYXRpb25TY29wZTogY2FwdHVyZWRTcGFuU2NvcGVzLmlzb2xhdGlvblNjb3BlLFxuICAgICAgc2FtcGxlUmF0ZSxcbiAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQ6IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHNwYW4gKSxcbiAgICB9LFxuICAgIC4uLihzb3VyY2UgJiYge1xuICAgICAgdHJhbnNhY3Rpb25faW5mbzoge1xuICAgICAgICBzb3VyY2UsXG4gICAgICB9LFxuICAgIH0pLFxuICB9O1xuXG4gIHJldHVybiB0cmFuc2FjdGlvbkV2ZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBbmRGaW5pc2hTcGFuRm9yT3RlbFNwYW4obm9kZSwgc3BhbnMsIHNlbnRTcGFucykge1xuICBjb25zdCBzcGFuID0gbm9kZS5zcGFuO1xuXG4gIGlmIChzcGFuKSB7XG4gICAgc2VudFNwYW5zLmFkZChzcGFuKTtcbiAgfVxuXG4gIGNvbnN0IHNob3VsZERyb3AgPSAhc3BhbjtcblxuICAvLyBJZiB0aGlzIHNwYW4gc2hvdWxkIGJlIGRyb3BwZWQsIHdlIHN0aWxsIHdhbnQgdG8gY3JlYXRlIHNwYW5zIGZvciB0aGUgY2hpbGRyZW4gb2YgdGhpc1xuICBpZiAoc2hvdWxkRHJvcCkge1xuICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBjcmVhdGVBbmRGaW5pc2hTcGFuRm9yT3RlbFNwYW4oY2hpbGQsIHNwYW5zLCBzZW50U3BhbnMpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHNwYW5faWQgPSBzcGFuLnNwYW5Db250ZXh0KCkuc3BhbklkO1xuICBjb25zdCB0cmFjZV9pZCA9IHNwYW4uc3BhbkNvbnRleHQoKS50cmFjZUlkO1xuICBjb25zdCBwYXJlbnRTcGFuSWQgPSBnZXRQYXJlbnRTcGFuSWQoc3Bhbik7XG5cbiAgY29uc3QgeyBhdHRyaWJ1dGVzLCBzdGFydFRpbWUsIGVuZFRpbWUsIGxpbmtzIH0gPSBzcGFuO1xuXG4gIGNvbnN0IHsgb3AsIGRlc2NyaXB0aW9uLCBkYXRhLCBvcmlnaW4gPSAnbWFudWFsJyB9ID0gZ2V0U3BhbkRhdGEoc3Bhbik7XG4gIGNvbnN0IGFsbERhdGEgPSB7XG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiBvcmlnaW4sXG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF06IG9wLFxuICAgIC4uLnJlbW92ZVNlbnRyeUF0dHJpYnV0ZXMoYXR0cmlidXRlcyksXG4gICAgLi4uZGF0YSxcbiAgfTtcblxuICBjb25zdCBzdGF0dXMgPSBtYXBTdGF0dXMoc3Bhbik7XG5cbiAgY29uc3Qgc3BhbkpTT04gPSB7XG4gICAgc3Bhbl9pZCxcbiAgICB0cmFjZV9pZCxcbiAgICBkYXRhOiBhbGxEYXRhLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIHBhcmVudF9zcGFuX2lkOiBwYXJlbnRTcGFuSWQsXG4gICAgc3RhcnRfdGltZXN0YW1wOiBjb3JlLnNwYW5UaW1lSW5wdXRUb1NlY29uZHMoc3RhcnRUaW1lKSxcbiAgICAvLyBUaGlzIGlzIFswLDBdIGJ5IGRlZmF1bHQgaW4gT1RFTCwgaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHRvIGludGVycHJldCB0aGlzIGFzIG5vIGVuZCB0aW1lXG4gICAgdGltZXN0YW1wOiBjb3JlLnNwYW5UaW1lSW5wdXRUb1NlY29uZHMoZW5kVGltZSkgfHwgdW5kZWZpbmVkLFxuICAgIHN0YXR1czogY29yZS5nZXRTdGF0dXNNZXNzYWdlKHN0YXR1cyksIC8vIEFzIHBlciBwcm90b2NvbCwgc3BhbiBzdGF0dXMgaXMgYWxsb3dlZCB0byBiZSB1bmRlZmluZWRcbiAgICBvcCxcbiAgICBvcmlnaW4sXG4gICAgbWVhc3VyZW1lbnRzOiBjb3JlLnRpbWVkRXZlbnRzVG9NZWFzdXJlbWVudHMoc3Bhbi5ldmVudHMpLFxuICAgIGxpbmtzOiBjb3JlLmNvbnZlcnRTcGFuTGlua3NGb3JFbnZlbG9wZShsaW5rcyksXG4gIH07XG5cbiAgc3BhbnMucHVzaChzcGFuSlNPTik7XG5cbiAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICBjcmVhdGVBbmRGaW5pc2hTcGFuRm9yT3RlbFNwYW4oY2hpbGQsIHNwYW5zLCBzZW50U3BhbnMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U3BhbkRhdGEoc3BhbilcblxuIHtcbiAgY29uc3QgeyBvcDogZGVmaW5lZE9wLCBzb3VyY2U6IGRlZmluZWRTb3VyY2UsIG9yaWdpbiB9ID0gcGFyc2VTcGFuKHNwYW4pO1xuICBjb25zdCB7IG9wOiBpbmZlcnJlZE9wLCBkZXNjcmlwdGlvbiwgc291cmNlOiBpbmZlcnJlZFNvdXJjZSwgZGF0YTogaW5mZXJyZWREYXRhIH0gPSBwYXJzZVNwYW5EZXNjcmlwdGlvbihzcGFuKTtcblxuICBjb25zdCBvcCA9IGRlZmluZWRPcCB8fCBpbmZlcnJlZE9wO1xuICBjb25zdCBzb3VyY2UgPSBkZWZpbmVkU291cmNlIHx8IGluZmVycmVkU291cmNlO1xuXG4gIGNvbnN0IGRhdGEgPSB7IC4uLmluZmVycmVkRGF0YSwgLi4uZ2V0RGF0YShzcGFuKSB9O1xuXG4gIHJldHVybiB7XG4gICAgb3AsXG4gICAgZGVzY3JpcHRpb24sXG4gICAgc291cmNlLFxuICAgIG9yaWdpbixcbiAgICBkYXRhLFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZSBjdXN0b20gYHNlbnRyeS5gIGF0dHJpYnV0ZXMgd2UgZG8gbm90IG5lZWQgdG8gc2VuZC5cbiAqIFRoZXNlIGFyZSBtb3JlIGNhcnJpZXIgYXR0cmlidXRlcyB3ZSB1c2UgaW5zaWRlIG9mIHRoZSBTREssIHdlIGRvIG5vdCBuZWVkIHRvIHNlbmQgdGhlbSB0byB0aGUgQVBJLlxuICovXG5mdW5jdGlvbiByZW1vdmVTZW50cnlBdHRyaWJ1dGVzKGRhdGEpIHtcbiAgY29uc3QgY2xlYW5lZERhdGEgPSB7IC4uLmRhdGEgfTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGUgKi9cbiAgZGVsZXRlIGNsZWFuZWREYXRhW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURV07XG4gIGRlbGV0ZSBjbGVhbmVkRGF0YVtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1BBUkVOVF9JU19SRU1PVEVdO1xuICBkZWxldGUgY2xlYW5lZERhdGFbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0NVU1RPTV9TUEFOX05BTUVdO1xuICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZSAqL1xuXG4gIHJldHVybiBjbGVhbmVkRGF0YTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YShzcGFuKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBzcGFuLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IGRhdGEgPSB7fTtcblxuICBpZiAoc3Bhbi5raW5kICE9PSBhcGkuU3BhbktpbmQuSU5URVJOQUwpIHtcbiAgICBkYXRhWydvdGVsLmtpbmQnXSA9IGFwaS5TcGFuS2luZFtzcGFuLmtpbmRdO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IG1heWJlSHR0cFN0YXR1c0NvZGVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9TVEFUVVNfQ09ERV07XG4gIGlmIChtYXliZUh0dHBTdGF0dXNDb2RlQXR0cmlidXRlKSB7XG4gICAgZGF0YVtzZW1hbnRpY0NvbnZlbnRpb25zLkFUVFJfSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERV0gPSBtYXliZUh0dHBTdGF0dXNDb2RlQXR0cmlidXRlIDtcbiAgfVxuXG4gIGNvbnN0IHJlcXVlc3REYXRhID0gZ2V0UmVxdWVzdFNwYW5EYXRhKHNwYW4pO1xuXG4gIGlmIChyZXF1ZXN0RGF0YS51cmwpIHtcbiAgICBkYXRhLnVybCA9IHJlcXVlc3REYXRhLnVybDtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0RGF0YVsnaHR0cC5xdWVyeSddKSB7XG4gICAgZGF0YVsnaHR0cC5xdWVyeSddID0gcmVxdWVzdERhdGFbJ2h0dHAucXVlcnknXS5zbGljZSgxKTtcbiAgfVxuICBpZiAocmVxdWVzdERhdGFbJ2h0dHAuZnJhZ21lbnQnXSkge1xuICAgIGRhdGFbJ2h0dHAuZnJhZ21lbnQnXSA9IHJlcXVlc3REYXRhWydodHRwLmZyYWdtZW50J10uc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gb25TcGFuU3RhcnQoc3BhbiwgcGFyZW50Q29udGV4dCkge1xuICAvLyBUaGlzIGlzIGEgcmVsaWFibGUgd2F5IHRvIGdldCB0aGUgcGFyZW50IHNwYW4gLSBiZWNhdXNlIHRoaXMgaXMgZXhhY3RseSBob3cgdGhlIHBhcmVudCBpcyBpZGVudGlmaWVkIGluIHRoZSBPVEVMIFNES1xuICBjb25zdCBwYXJlbnRTcGFuID0gYXBpLnRyYWNlLmdldFNwYW4ocGFyZW50Q29udGV4dCk7XG5cbiAgbGV0IHNjb3BlcyA9IGdldFNjb3Blc0Zyb21Db250ZXh0KHBhcmVudENvbnRleHQpO1xuXG4gIC8vIFdlIG5lZWQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgc3BhbiBpbiBvcmRlciB0byBiZSBhYmxlIHRvIG1vdmUgdXAgdGhlIHNwYW4gdHJlZSBmb3IgYnJlYWRjcnVtYnNcbiAgaWYgKHBhcmVudFNwYW4gJiYgIXBhcmVudFNwYW4uc3BhbkNvbnRleHQoKS5pc1JlbW90ZSkge1xuICAgIGNvcmUuYWRkQ2hpbGRTcGFuVG9TcGFuKHBhcmVudFNwYW4sIHNwYW4pO1xuICB9XG5cbiAgLy8gV2UgbmVlZCB0aGlzIGluIHRoZSBzcGFuIGV4cG9ydGVyXG4gIGlmIChwYXJlbnRTcGFuPy5zcGFuQ29udGV4dCgpLmlzUmVtb3RlKSB7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QQVJFTlRfSVNfUkVNT1RFLCB0cnVlKTtcbiAgfVxuXG4gIC8vIFRoZSByb290IGNvbnRleHQgZG9lcyBub3QgaGF2ZSBzY29wZXMgc3RvcmVkLCBzbyB3ZSBjaGVjayBmb3IgdGhpcyBzcGVjaWZpY2FsbHlcbiAgLy8gQXMgZmFsbGJhY2sgd2UgYXR0YWNoIHRoZSBnbG9iYWwgc2NvcGVzXG4gIGlmIChwYXJlbnRDb250ZXh0ID09PSBhcGkuUk9PVF9DT05URVhUKSB7XG4gICAgc2NvcGVzID0ge1xuICAgICAgc2NvcGU6IGNvcmUuZ2V0RGVmYXVsdEN1cnJlbnRTY29wZSgpLFxuICAgICAgaXNvbGF0aW9uU2NvcGU6IGNvcmUuZ2V0RGVmYXVsdElzb2xhdGlvblNjb3BlKCksXG4gICAgfTtcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdGhlIHNjb3BlIGF0IHRpbWUgb2Ygc3BhbiBjcmVhdGlvbiBpbiBvcmRlciB0byBhcHBseSBpdCB0byB0aGUgZXZlbnQgd2hlbiB0aGUgc3BhbiBpcyBmaW5pc2hlZFxuICBpZiAoc2NvcGVzKSB7XG4gICAgY29yZS5zZXRDYXB0dXJlZFNjb3Blc09uU3BhbihzcGFuLCBzY29wZXMuc2NvcGUsIHNjb3Blcy5pc29sYXRpb25TY29wZSk7XG4gIH1cblxuICBjb3JlLmxvZ1NwYW5TdGFydChzcGFuKTtcblxuICBjb25zdCBjbGllbnQgPSBjb3JlLmdldENsaWVudCgpO1xuICBjbGllbnQ/LmVtaXQoJ3NwYW5TdGFydCcsIHNwYW4pO1xufVxuXG5mdW5jdGlvbiBvblNwYW5FbmQoc3Bhbikge1xuICBjb3JlLmxvZ1NwYW5FbmQoc3Bhbik7XG5cbiAgY29uc3QgY2xpZW50ID0gY29yZS5nZXRDbGllbnQoKTtcbiAgY2xpZW50Py5lbWl0KCdzcGFuRW5kJywgc3Bhbik7XG59XG5cbi8qKlxuICogQ29udmVydHMgT3BlblRlbGVtZXRyeSBTcGFucyB0byBTZW50cnkgU3BhbnMgYW5kIHNlbmRzIHRoZW0gdG8gU2VudHJ5IHZpYVxuICogdGhlIFNlbnRyeSBTREsuXG4gKi9cbmNsYXNzIFNlbnRyeVNwYW5Qcm9jZXNzb3IgIHtcblxuICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHNldElzU2V0dXAoJ1NlbnRyeVNwYW5Qcm9jZXNzb3InKTtcbiAgICB0aGlzLl9leHBvcnRlciA9IG5ldyBTZW50cnlTcGFuRXhwb3J0ZXIob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBhc3luYyBmb3JjZUZsdXNoKCkge1xuICAgIHRoaXMuX2V4cG9ydGVyLmZsdXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBhc3luYyBzaHV0ZG93bigpIHtcbiAgICB0aGlzLl9leHBvcnRlci5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgb25TdGFydChzcGFuLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgb25TcGFuU3RhcnQoc3BhbiwgcGFyZW50Q29udGV4dCk7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgIG9uRW5kKHNwYW4pIHtcbiAgICBvblNwYW5FbmQoc3Bhbik7XG5cbiAgICB0aGlzLl9leHBvcnRlci5leHBvcnQoc3Bhbik7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGN1c3RvbSBPVEVMIHNhbXBsZXIgdGhhdCB1c2VzIFNlbnRyeSBzYW1wbGluZyByYXRlcyB0byBtYWtlIGl0cyBkZWNpc2lvblxuICovXG5jbGFzcyBTZW50cnlTYW1wbGVyICB7XG5cbiAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICBzZXRJc1NldHVwKCdTZW50cnlTYW1wbGVyJyk7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgIHNob3VsZFNhbXBsZShcbiAgICBjb250ZXh0LFxuICAgIHRyYWNlSWQsXG4gICAgc3Bhbk5hbWUsXG4gICAgc3BhbktpbmQsXG4gICAgc3BhbkF0dHJpYnV0ZXMsXG4gICAgX2xpbmtzLFxuICApIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fY2xpZW50LmdldE9wdGlvbnMoKTtcblxuICAgIGNvbnN0IHBhcmVudFNwYW4gPSBnZXRWYWxpZFNwYW4oY29udGV4dCk7XG4gICAgY29uc3QgcGFyZW50Q29udGV4dCA9IHBhcmVudFNwYW4/LnNwYW5Db250ZXh0KCk7XG5cbiAgICBpZiAoIWNvcmUuaGFzU3BhbnNFbmFibGVkKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gd3JhcFNhbXBsaW5nRGVjaXNpb24oeyBkZWNpc2lvbjogdW5kZWZpbmVkLCBjb250ZXh0LCBzcGFuQXR0cmlidXRlcyB9KTtcbiAgICB9XG5cbiAgICAvLyBgQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EYCBpcyB0aGUgbmV3IGF0dHJpYnV0ZSwgYnV0IHdlIHN0aWxsIHN1cHBvcnQgdGhlIG9sZCBvbmUsIGBTRU1BVFRSU19IVFRQX01FVEhPRGAsIGZvciBub3cuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgY29uc3QgbWF5YmVTcGFuSHR0cE1ldGhvZCA9IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9NRVRIT0RdIHx8IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EXTtcblxuICAgIC8vIElmIHdlIGhhdmUgYSBodHRwLmNsaWVudCBzcGFuIHRoYXQgaGFzIG5vIGxvY2FsIHBhcmVudCwgd2UgbmV2ZXIgd2FudCB0byBzYW1wbGUgaXRcbiAgICAvLyBidXQgd2Ugd2FudCB0byBsZWF2ZSBkb3duc3RyZWFtIHNhbXBsaW5nIGRlY2lzaW9ucyB1cCB0byB0aGUgc2VydmVyXG4gICAgaWYgKHNwYW5LaW5kID09PSBhcGkuU3BhbktpbmQuQ0xJRU5UICYmIG1heWJlU3Bhbkh0dHBNZXRob2QgJiYgKCFwYXJlbnRTcGFuIHx8IHBhcmVudENvbnRleHQ/LmlzUmVtb3RlKSkge1xuICAgICAgcmV0dXJuIHdyYXBTYW1wbGluZ0RlY2lzaW9uKHsgZGVjaXNpb246IHVuZGVmaW5lZCwgY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50U2FtcGxlZCA9IHBhcmVudFNwYW4gPyBnZXRQYXJlbnRTYW1wbGVkKHBhcmVudFNwYW4sIHRyYWNlSWQsIHNwYW5OYW1lKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpc1Jvb3RTcGFuID0gIXBhcmVudFNwYW4gfHwgcGFyZW50Q29udGV4dD8uaXNSZW1vdGU7XG5cbiAgICAvLyBXZSBvbmx5IHNhbXBsZSBiYXNlZCBvbiBwYXJhbWV0ZXJzIChsaWtlIHRyYWNlc1NhbXBsZVJhdGUgb3IgdHJhY2VzU2FtcGxlcikgZm9yIHJvb3Qgc3BhbnMgKHdoaWNoIGlzIGRvbmUgaW4gc2FtcGxlU3BhbikuXG4gICAgLy8gTm9uLXJvb3Qtc3BhbnMgc2ltcGx5IGluaGVyaXQgdGhlIHNhbXBsaW5nIGRlY2lzaW9uIGZyb20gdGhlaXIgcGFyZW50LlxuICAgIGlmICghaXNSb290U3Bhbikge1xuICAgICAgcmV0dXJuIHdyYXBTYW1wbGluZ0RlY2lzaW9uKHtcbiAgICAgICAgZGVjaXNpb246IHBhcmVudFNhbXBsZWQgPyBzZGtUcmFjZUJhc2UuU2FtcGxpbmdEZWNpc2lvbi5SRUNPUkRfQU5EX1NBTVBMRUQgOiBzZGtUcmFjZUJhc2UuU2FtcGxpbmdEZWNpc2lvbi5OT1RfUkVDT1JELFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBzcGFuQXR0cmlidXRlcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFdlIHdhbnQgdG8gcGFzcyB0aGUgaW5mZXJyZWQgbmFtZSAmIGF0dHJpYnV0ZXMgdG8gdGhlIHNhbXBsZXIgbWV0aG9kXG4gICAgY29uc3Qge1xuICAgICAgZGVzY3JpcHRpb246IGluZmVycmVkU3Bhbk5hbWUsXG4gICAgICBkYXRhOiBpbmZlcnJlZEF0dHJpYnV0ZXMsXG4gICAgICBvcCxcbiAgICB9ID0gaW5mZXJTcGFuRGF0YShzcGFuTmFtZSwgc3BhbkF0dHJpYnV0ZXMsIHNwYW5LaW5kKTtcblxuICAgIGNvbnN0IG1lcmdlZEF0dHJpYnV0ZXMgPSB7XG4gICAgICAuLi5pbmZlcnJlZEF0dHJpYnV0ZXMsXG4gICAgICAuLi5zcGFuQXR0cmlidXRlcyxcbiAgICB9O1xuXG4gICAgaWYgKG9wKSB7XG4gICAgICBtZXJnZWRBdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF0gPSBvcDtcbiAgICB9XG5cbiAgICBjb25zdCBtdXRhYmxlU2FtcGxpbmdEZWNpc2lvbiA9IHsgZGVjaXNpb246IHRydWUgfTtcbiAgICB0aGlzLl9jbGllbnQuZW1pdChcbiAgICAgICdiZWZvcmVTYW1wbGluZycsXG4gICAgICB7XG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzOiBtZXJnZWRBdHRyaWJ1dGVzLFxuICAgICAgICBzcGFuTmFtZTogaW5mZXJyZWRTcGFuTmFtZSxcbiAgICAgICAgcGFyZW50U2FtcGxlZDogcGFyZW50U2FtcGxlZCxcbiAgICAgICAgcGFyZW50Q29udGV4dDogcGFyZW50Q29udGV4dCxcbiAgICAgIH0sXG4gICAgICBtdXRhYmxlU2FtcGxpbmdEZWNpc2lvbixcbiAgICApO1xuICAgIGlmICghbXV0YWJsZVNhbXBsaW5nRGVjaXNpb24uZGVjaXNpb24pIHtcbiAgICAgIHJldHVybiB3cmFwU2FtcGxpbmdEZWNpc2lvbih7IGRlY2lzaW9uOiB1bmRlZmluZWQsIGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHsgaXNvbGF0aW9uU2NvcGUgfSA9IGdldFNjb3Blc0Zyb21Db250ZXh0KGNvbnRleHQpID8/IHt9O1xuXG4gICAgY29uc3QgZHNjU3RyaW5nID0gcGFyZW50Q29udGV4dD8udHJhY2VTdGF0ZSA/IHBhcmVudENvbnRleHQudHJhY2VTdGF0ZS5nZXQoU0VOVFJZX1RSQUNFX1NUQVRFX0RTQykgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZHNjID0gZHNjU3RyaW5nID8gY29yZS5iYWdnYWdlSGVhZGVyVG9EeW5hbWljU2FtcGxpbmdDb250ZXh0KGRzY1N0cmluZykgOiB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBzYW1wbGVSYW5kID0gY29yZS5wYXJzZVNhbXBsZVJhdGUoZHNjPy5zYW1wbGVfcmFuZCkgPz8gTWF0aC5yYW5kb20oKTtcblxuICAgIGNvbnN0IFtzYW1wbGVkLCBzYW1wbGVSYXRlLCBsb2NhbFNhbXBsZVJhdGVXYXNBcHBsaWVkXSA9IGNvcmUuc2FtcGxlU3BhbihcbiAgICAgIG9wdGlvbnMsXG4gICAgICB7XG4gICAgICAgIG5hbWU6IGluZmVycmVkU3Bhbk5hbWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IG1lcmdlZEF0dHJpYnV0ZXMsXG4gICAgICAgIG5vcm1hbGl6ZWRSZXF1ZXN0OiBpc29sYXRpb25TY29wZT8uZ2V0U2NvcGVEYXRhKCkuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLm5vcm1hbGl6ZWRSZXF1ZXN0LFxuICAgICAgICBwYXJlbnRTYW1wbGVkLFxuICAgICAgICBwYXJlbnRTYW1wbGVSYXRlOiBjb3JlLnBhcnNlU2FtcGxlUmF0ZShkc2M/LnNhbXBsZV9yYXRlKSxcbiAgICAgIH0sXG4gICAgICBzYW1wbGVSYW5kLFxuICAgICk7XG5cbiAgICBjb25zdCBtZXRob2QgPSBgJHttYXliZVNwYW5IdHRwTWV0aG9kfWAudG9VcHBlckNhc2UoKTtcbiAgICBpZiAobWV0aG9kID09PSAnT1BUSU9OUycgfHwgbWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIGNvcmUuZGVidWcubG9nKGBbVHJhY2luZ10gTm90IHNhbXBsaW5nIHNwYW4gYmVjYXVzZSBIVFRQIG1ldGhvZCBpcyAnJHttZXRob2R9JyBmb3IgJHtzcGFuTmFtZX1gKTtcblxuICAgICAgcmV0dXJuIHdyYXBTYW1wbGluZ0RlY2lzaW9uKHtcbiAgICAgICAgZGVjaXNpb246IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLk5PVF9SRUNPUkQsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzLFxuICAgICAgICBzYW1wbGVSYW5kLFxuICAgICAgICBkb3duc3RyZWFtVHJhY2VTYW1wbGVSYXRlOiAwLCAvLyB3ZSBkb24ndCB3YW50IHRvIHNhbXBsZSBhbnl0aGluZyBpbiB0aGUgZG93bnN0cmVhbSB0cmFjZSBlaXRoZXJcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFzYW1wbGVkICYmXG4gICAgICAvLyBXZSBjaGVjayBmb3IgYHBhcmVudFNhbXBsZWQgPT09IHVuZGVmaW5lZGAgYmVjYXVzZSB3ZSBvbmx5IHdhbnQgdG8gcmVjb3JkIGNsaWVudCByZXBvcnRzIGZvciBzcGFucyB0aGF0IGFyZSB0cmFjZSByb290cyAoaWUuIHdoZW4gdGhlcmUgd2FzIGluY29taW5nIHRyYWNlKVxuICAgICAgcGFyZW50U2FtcGxlZCA9PT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBjb3JlLmRlYnVnLmxvZygnW1RyYWNpbmddIERpc2NhcmRpbmcgcm9vdCBzcGFuIGJlY2F1c2UgaXRzIHRyYWNlIHdhcyBub3QgY2hvc2VuIHRvIGJlIHNhbXBsZWQuJyk7XG4gICAgICB0aGlzLl9jbGllbnQucmVjb3JkRHJvcHBlZEV2ZW50KCdzYW1wbGVfcmF0ZScsICd0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi53cmFwU2FtcGxpbmdEZWNpc2lvbih7XG4gICAgICAgIGRlY2lzaW9uOiBzYW1wbGVkID8gc2RrVHJhY2VCYXNlLlNhbXBsaW5nRGVjaXNpb24uUkVDT1JEX0FORF9TQU1QTEVEIDogc2RrVHJhY2VCYXNlLlNhbXBsaW5nRGVjaXNpb24uTk9UX1JFQ09SRCxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgc3BhbkF0dHJpYnV0ZXMsXG4gICAgICAgIHNhbXBsZVJhbmQsXG4gICAgICAgIGRvd25zdHJlYW1UcmFjZVNhbXBsZVJhdGU6IGxvY2FsU2FtcGxlUmF0ZVdhc0FwcGxpZWQgPyBzYW1wbGVSYXRlIDogdW5kZWZpbmVkLFxuICAgICAgfSksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC8vIFdlIHNldCB0aGUgc2FtcGxlIHJhdGUgb24gdGhlIHNwYW4gd2hlbiBhIGxvY2FsIHNhbXBsZSByYXRlIHdhcyBhcHBsaWVkIHRvIGJldHRlciB1bmRlcnN0YW5kIGhvdyB0cmFjZXMgd2VyZSBzYW1wbGVkIGluIFNlbnRyeVxuICAgICAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFXTogbG9jYWxTYW1wbGVSYXRlV2FzQXBwbGllZCA/IHNhbXBsZVJhdGUgOiB1bmRlZmluZWQsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgc2FtcGxlciBuYW1lIG9yIHNob3J0IGRlc2NyaXB0aW9uIHdpdGggdGhlIGNvbmZpZ3VyYXRpb24uICovXG4gICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1NlbnRyeVNhbXBsZXInO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudFNhbXBsZWQocGFyZW50U3BhbiwgdHJhY2VJZCwgc3Bhbk5hbWUpIHtcbiAgY29uc3QgcGFyZW50Q29udGV4dCA9IHBhcmVudFNwYW4uc3BhbkNvbnRleHQoKTtcblxuICAvLyBPbmx5IGluaGVyaXQgc2FtcGxlIHJhdGUgaWYgYHRyYWNlSWRgIGlzIHRoZSBzYW1lXG4gIC8vIE5vdGUgZm9yIHRlc3Rpbmc6IGBpc1NwYW5Db250ZXh0VmFsaWQoKWAgY2hlY2tzIHRoZSBmb3JtYXQgb2YgdGhlIHRyYWNlSWQvc3BhbklkLCBzbyB3ZSBuZWVkIHRvIHBhc3MgdmFsaWQgb25lc1xuICBpZiAoYXBpLmlzU3BhbkNvbnRleHRWYWxpZChwYXJlbnRDb250ZXh0KSAmJiBwYXJlbnRDb250ZXh0LnRyYWNlSWQgPT09IHRyYWNlSWQpIHtcbiAgICBpZiAocGFyZW50Q29udGV4dC5pc1JlbW90ZSkge1xuICAgICAgY29uc3QgcGFyZW50U2FtcGxlZCA9IGdldFNhbXBsaW5nRGVjaXNpb24ocGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpKTtcbiAgICAgIERFQlVHX0JVSUxEICYmXG4gICAgICAgIGNvcmUuZGVidWcubG9nKGBbVHJhY2luZ10gSW5oZXJpdGluZyByZW1vdGUgcGFyZW50J3Mgc2FtcGxlZCBkZWNpc2lvbiBmb3IgJHtzcGFuTmFtZX06ICR7cGFyZW50U2FtcGxlZH1gKTtcbiAgICAgIHJldHVybiBwYXJlbnRTYW1wbGVkO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudFNhbXBsZWQgPSBnZXRTYW1wbGluZ0RlY2lzaW9uKHBhcmVudENvbnRleHQpO1xuICAgIERFQlVHX0JVSUxEICYmIGNvcmUuZGVidWcubG9nKGBbVHJhY2luZ10gSW5oZXJpdGluZyBwYXJlbnQncyBzYW1wbGVkIGRlY2lzaW9uIGZvciAke3NwYW5OYW1lfTogJHtwYXJlbnRTYW1wbGVkfWApO1xuICAgIHJldHVybiBwYXJlbnRTYW1wbGVkO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBXcmFwIGEgc2FtcGxpbmcgZGVjaXNpb24gd2l0aCBkYXRhIHRoYXQgU2VudHJ5IG5lZWRzIHRvIHdvcmsgcHJvcGVybHkgd2l0aCBpdC5cbiAqIElmIHlvdSBwYXNzIGBkZWNpc2lvbjogdW5kZWZpbmVkYCwgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGBOT1RfUkVDT1JESU5HYCwgYnV0IGluIGNvbnRyYXN0IHRvIHBhc3NpbmcgYE5PVF9SRUNPUkRJTkdgXG4gKiBpdCB3aWxsIG5vdCBwcm9wYWdhdGUgdGhpcyBkZWNpc2lvbiB0byBkb3duc3RyZWFtIFNlbnRyeSBTREtzLlxuICovXG5mdW5jdGlvbiB3cmFwU2FtcGxpbmdEZWNpc2lvbih7XG4gIGRlY2lzaW9uLFxuICBjb250ZXh0LFxuICBzcGFuQXR0cmlidXRlcyxcbiAgc2FtcGxlUmFuZCxcbiAgZG93bnN0cmVhbVRyYWNlU2FtcGxlUmF0ZSxcbn1cblxuKSB7XG4gIGxldCB0cmFjZVN0YXRlID0gZ2V0QmFzZVRyYWNlU3RhdGUoY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMpO1xuXG4gIC8vIFdlIHdpbGwgb3ZlcnJpZGUgdGhlIHByb3BhZ2F0ZWQgc2FtcGxlIHJhdGUgZG93bnN0cmVhbSB3aGVuXG4gIC8vIC0gdGhlIHRyYWNlc1NhbXBsZVJhdGUgaXMgYXBwbGllZFxuICAvLyAtIHRoZSB0cmFjZXNTYW1wbGVyIGlzIGludm9rZWRcbiAgLy8gU2luY2UgdW5zYW1wbGVkIE9URUwgc3BhbnMgKE5vblJlY29yZGluZ1NwYW5zKSBjYW5ub3QgaG9sZCBhdHRyaWJ1dGVzIHdlIG5lZWQgdG8gc3RvcmUgdGhpcyBvbiB0aGUgKHRyYWNlKWNvbnRleHQuXG4gIGlmIChkb3duc3RyZWFtVHJhY2VTYW1wbGVSYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0cmFjZVN0YXRlID0gdHJhY2VTdGF0ZS5zZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRV9SQVRFLCBgJHtkb3duc3RyZWFtVHJhY2VTYW1wbGVSYXRlfWApO1xuICB9XG5cbiAgaWYgKHNhbXBsZVJhbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIHRyYWNlU3RhdGUgPSB0cmFjZVN0YXRlLnNldChTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFX1JBTkQsIGAke3NhbXBsZVJhbmR9YCk7XG4gIH1cblxuICAvLyBJZiB0aGUgZGVjaXNpb24gaXMgdW5kZWZpbmVkLCB3ZSB0cmVhdCBpdCBhcyBOT1RfUkVDT1JESU5HLCBidXQgd2UgZG9uJ3QgcHJvcGFnYXRlIHRoaXMgZGVjaXNpb24gdG8gZG93bnN0cmVhbSBTREtzXG4gIC8vIFdoaWNoIGlzIGRvbmUgYnkgbm90IHNldHRpbmcgYFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkdgIHRyYWNlU3RhdGVcbiAgaWYgKGRlY2lzaW9uID09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7IGRlY2lzaW9uOiBzZGtUcmFjZUJhc2UuU2FtcGxpbmdEZWNpc2lvbi5OT1RfUkVDT1JELCB0cmFjZVN0YXRlIH07XG4gIH1cblxuICBpZiAoZGVjaXNpb24gPT09IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLk5PVF9SRUNPUkQpIHtcbiAgICByZXR1cm4geyBkZWNpc2lvbiwgdHJhY2VTdGF0ZTogdHJhY2VTdGF0ZS5zZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElORywgJzEnKSB9O1xuICB9XG5cbiAgcmV0dXJuIHsgZGVjaXNpb24sIHRyYWNlU3RhdGUgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QmFzZVRyYWNlU3RhdGUoY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMpIHtcbiAgY29uc3QgcGFyZW50U3BhbiA9IGFwaS50cmFjZS5nZXRTcGFuKGNvbnRleHQpO1xuICBjb25zdCBwYXJlbnRDb250ZXh0ID0gcGFyZW50U3Bhbj8uc3BhbkNvbnRleHQoKTtcblxuICBsZXQgdHJhY2VTdGF0ZSA9IHBhcmVudENvbnRleHQ/LnRyYWNlU3RhdGUgfHwgbmV3IGNvcmUkMS5UcmFjZVN0YXRlKCk7XG5cbiAgLy8gV2UgYWx3YXlzIGtlZXAgdGhlIFVSTCBvbiB0aGUgdHJhY2Ugc3RhdGUsIHNvIHdlIGNhbiBhY2Nlc3MgaXQgaW4gdGhlIHByb3BhZ2F0b3JcbiAgLy8gYEFUVFJfVVJMX0ZVTExgIGlzIHRoZSBuZXcgYXR0cmlidXRlLCBidXQgd2Ugc3RpbGwgc3VwcG9ydCB0aGUgb2xkIG9uZSwgYEFUVFJfSFRUUF9VUkxgLCBmb3Igbm93LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgdXJsID0gc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1VSTF0gfHwgc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX1VSTF9GVUxMXTtcbiAgaWYgKHVybCAmJiB0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgIHRyYWNlU3RhdGUgPSB0cmFjZVN0YXRlLnNldChTRU5UUllfVFJBQ0VfU1RBVEVfVVJMLCB1cmwpO1xuICB9XG5cbiAgcmV0dXJuIHRyYWNlU3RhdGU7XG59XG5cbi8qKlxuICogSWYgdGhlIGFjdGl2ZSBzcGFuIGlzIGludmFsaWQsIHdlIHdhbnQgdG8gaWdub3JlIGl0IGFzIHBhcmVudC5cbiAqIFRoaXMgYWxpZ25zIHdpdGggaG93IG90ZWwgdHJhY2VycyBhbmQgZGVmYXVsdCBzYW1wbGVycyBoYW5kbGUgdGhlc2UgY2FzZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbGlkU3Bhbihjb250ZXh0KSB7XG4gIGNvbnN0IHNwYW4gPSBhcGkudHJhY2UuZ2V0U3Bhbihjb250ZXh0KTtcbiAgcmV0dXJuIHNwYW4gJiYgYXBpLmlzU3BhbkNvbnRleHRWYWxpZChzcGFuLnNwYW5Db250ZXh0KCkpID8gc3BhbiA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0cy5nZXRDbGllbnQgPSBjb3JlLmdldENsaWVudDtcbmV4cG9ydHMuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuID0gY29yZS5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW47XG5leHBvcnRzLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfR1JBUEhRTF9PUEVSQVRJT04gPSBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0dSQVBIUUxfT1BFUkFUSU9OO1xuZXhwb3J0cy5TZW50cnlQcm9wYWdhdG9yID0gU2VudHJ5UHJvcGFnYXRvcjtcbmV4cG9ydHMuU2VudHJ5U2FtcGxlciA9IFNlbnRyeVNhbXBsZXI7XG5leHBvcnRzLlNlbnRyeVNwYW5Qcm9jZXNzb3IgPSBTZW50cnlTcGFuUHJvY2Vzc29yO1xuZXhwb3J0cy5jb250aW51ZVRyYWNlID0gY29udGludWVUcmFjZTtcbmV4cG9ydHMuZW5oYW5jZURzY1dpdGhPcGVuVGVsZW1ldHJ5Um9vdFNwYW5OYW1lID0gZW5oYW5jZURzY1dpdGhPcGVuVGVsZW1ldHJ5Um9vdFNwYW5OYW1lO1xuZXhwb3J0cy5nZXRBY3RpdmVTcGFuID0gZ2V0QWN0aXZlU3BhbjtcbmV4cG9ydHMuZ2V0UmVxdWVzdFNwYW5EYXRhID0gZ2V0UmVxdWVzdFNwYW5EYXRhO1xuZXhwb3J0cy5nZXRTY29wZXNGcm9tQ29udGV4dCA9IGdldFNjb3Blc0Zyb21Db250ZXh0O1xuZXhwb3J0cy5nZXRTcGFuS2luZCA9IGdldFNwYW5LaW5kO1xuZXhwb3J0cy5nZXRUcmFjZUNvbnRleHRGb3JTY29wZSA9IGdldFRyYWNlQ29udGV4dEZvclNjb3BlO1xuZXhwb3J0cy5pc1NlbnRyeVJlcXVlc3RTcGFuID0gaXNTZW50cnlSZXF1ZXN0U3BhbjtcbmV4cG9ydHMub3BlblRlbGVtZXRyeVNldHVwQ2hlY2sgPSBvcGVuVGVsZW1ldHJ5U2V0dXBDaGVjaztcbmV4cG9ydHMuc2V0T3BlblRlbGVtZXRyeUNvbnRleHRBc3luY0NvbnRleHRTdHJhdGVneSA9IHNldE9wZW5UZWxlbWV0cnlDb250ZXh0QXN5bmNDb250ZXh0U3RyYXRlZ3k7XG5leHBvcnRzLnNldHVwRXZlbnRDb250ZXh0VHJhY2UgPSBzZXR1cEV2ZW50Q29udGV4dFRyYWNlO1xuZXhwb3J0cy5zaG91bGRQcm9wYWdhdGVUcmFjZUZvclVybCA9IHNob3VsZFByb3BhZ2F0ZVRyYWNlRm9yVXJsO1xuZXhwb3J0cy5zcGFuSGFzQXR0cmlidXRlcyA9IHNwYW5IYXNBdHRyaWJ1dGVzO1xuZXhwb3J0cy5zcGFuSGFzRXZlbnRzID0gc3Bhbkhhc0V2ZW50cztcbmV4cG9ydHMuc3Bhbkhhc0tpbmQgPSBzcGFuSGFzS2luZDtcbmV4cG9ydHMuc3Bhbkhhc05hbWUgPSBzcGFuSGFzTmFtZTtcbmV4cG9ydHMuc3Bhbkhhc1BhcmVudElkID0gc3Bhbkhhc1BhcmVudElkO1xuZXhwb3J0cy5zcGFuSGFzU3RhdHVzID0gc3Bhbkhhc1N0YXR1cztcbmV4cG9ydHMuc3RhcnRJbmFjdGl2ZVNwYW4gPSBzdGFydEluYWN0aXZlU3BhbjtcbmV4cG9ydHMuc3RhcnRTcGFuID0gc3RhcnRTcGFuO1xuZXhwb3J0cy5zdGFydFNwYW5NYW51YWwgPSBzdGFydFNwYW5NYW51YWw7XG5leHBvcnRzLnN1cHByZXNzVHJhY2luZyA9IHN1cHByZXNzVHJhY2luZztcbmV4cG9ydHMud2l0aEFjdGl2ZVNwYW4gPSB3aXRoQWN0aXZlU3BhbjtcbmV4cG9ydHMud3JhcENsaWVudENsYXNzID0gd3JhcENsaWVudENsYXNzO1xuZXhwb3J0cy53cmFwQ29udGV4dE1hbmFnZXJDbGFzcyA9IHdyYXBDb250ZXh0TWFuYWdlckNsYXNzO1xuZXhwb3J0cy53cmFwU2FtcGxpbmdEZWNpc2lvbiA9IHdyYXBTYW1wbGluZ0RlY2lzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@sentry+opentelemetry@10.16_6ab421456e2f0bf04c66c14f54985fe1/node_modules/@sentry/opentelemetry/build/cjs/index.js\n");

/***/ })

};
;